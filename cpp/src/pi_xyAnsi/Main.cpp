// Generated by Haxe 5.0.0-alpha.1+1423a5f
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_ANSI
#include <ANSI.h>
#endif
#ifndef INCLUDED_Attribute
#include <Attribute.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_Sys
#include <Sys.h>
#endif
#ifndef INCLUDED_haxe_ds_GenericCell_Int
#include <haxe/ds/GenericCell_Int.h>
#endif
#ifndef INCLUDED_haxe_ds_GenericStack_Int
#include <haxe/ds/GenericStack_Int.h>
#endif
#ifndef INCLUDED_haxe_io_ArrayBufferViewImpl
#include <haxe/io/ArrayBufferViewImpl.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_haxe_io_Encoding
#include <haxe/io/Encoding.h>
#endif
#ifndef INCLUDED_haxe_io_Output
#include <haxe/io/Output.h>
#endif
#ifndef INCLUDED_iterMagic_ArrIntImg
#include <iterMagic/ArrIntImg.h>
#endif
#ifndef INCLUDED_iterMagic_BytesImg
#include <iterMagic/BytesImg.h>
#endif
#ifndef INCLUDED_iterMagic_Iimg
#include <iterMagic/Iimg.h>
#endif
#ifndef INCLUDED_iterMagic_StackIntImg
#include <iterMagic/StackIntImg.h>
#endif
#ifndef INCLUDED_iterMagic_U32ArrImg
#include <iterMagic/U32ArrImg.h>
#endif
#ifndef INCLUDED_iterMagic_U8ArrImg
#include <iterMagic/U8ArrImg.h>
#endif
#ifndef INCLUDED_iterMagic_VecIntImg
#include <iterMagic/VecIntImg.h>
#endif
#ifndef INCLUDED_pi_xy_ImageStruct
#include <pi_xy/ImageStruct.h>
#endif
#ifndef INCLUDED_pi_xy__Endian_Endian_Fields_
#include <pi_xy/_Endian/Endian_Fields_.h>
#endif
#ifndef INCLUDED_pi_xy_algo_HitTri
#include <pi_xy/algo/HitTri.h>
#endif
#ifndef INCLUDED_pi_xy_algo_IhitObj
#include <pi_xy/algo/IhitObj.h>
#endif
#ifndef INCLUDED_pi_xy_algo_TriPoints_
#include <pi_xy/algo/TriPoints_.h>
#endif
#ifndef INCLUDED_pi_xy_imageAbstracts_RGBratios
#include <pi_xy/imageAbstracts/RGBratios.h>
#endif
#ifndef INCLUDED_pi_xy_iter_IntIterStart
#include <pi_xy/iter/IntIterStart.h>
#endif
#ifndef INCLUDED_pi_xyAnsi_Main
#include <pi_xyAnsi/Main.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_78f112240a2e3029_7_new,"pi_xyAnsi.Main","new",0x8c86058f,"pi_xyAnsi.Main.new","src/pi_xyAnsi/Main.hx",7,0x3da59db5)
HX_LOCAL_STACK_FRAME(_hx_pos_78f112240a2e3029_5_main,"pi_xyAnsi.Main","main",0x68128c2a,"pi_xyAnsi.Main.main","src/pi_xyAnsi/Main.hx",5,0x3da59db5)
namespace pi_xyAnsi{

void Main_obj::__construct(){
            	HX_GC_STACKFRAME(&_hx_pos_78f112240a2e3029_7_new)
HXLINE(   8)		 ::Dynamic imageType = null();
HXDLIN(   8)		 ::pi_xy::ImageStruct this1 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(   8)		if (::hx::IsNull( imageType )) {
HXLINE(  54)			imageType = ::pi_xy::ImageStruct_obj::defaultType;
            		}
HXLINE(   8)		::Dynamic _hx_tmp;
HXDLIN(   8)		switch((int)(( (int)(imageType) ))){
            			case (int)0: {
HXLINE(   8)				 ::iterMagic::BytesImg byt =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(   8)				 ::iterMagic::BytesImg b = byt;
HXDLIN(   8)				{
HXLINE(   8)					 ::iterMagic::BytesImg _this = b;
HXDLIN(   8)					_this->width = 100;
HXDLIN(   8)					_this->height = 100;
HXDLIN(   8)					_this->length = 10000;
HXDLIN(   8)					_this->data = ::haxe::io::Bytes_obj::alloc((_this->length * 4));
HXDLIN(   8)					{
HXLINE(   8)						int len = _this->length;
HXDLIN(   8)						int w = 0;
HXDLIN(   8)						{
HXLINE(   8)							int _g = 0;
HXDLIN(   8)							int _g1 = _this->height;
HXDLIN(   8)							while((_g < _g1)){
HXLINE(   8)								_g = (_g + 1);
HXDLIN(   8)								int y = (_g - 1);
HXDLIN(   8)								{
HXLINE(   8)									int _g2 = 0;
HXDLIN(   8)									int _g3 = _this->width;
HXDLIN(   8)									while((_g2 < _g3)){
HXLINE(   8)										_g2 = (_g2 + 1);
HXDLIN(   8)										int x = (_g2 - 1);
HXDLIN(   8)										{
HXLINE(   8)											w = (w + 1);
HXDLIN(   8)											_this->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(   8)										{
HXLINE(   8)											w = (w + 1);
HXDLIN(   8)											_this->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(   8)										{
HXLINE(   8)											w = (w + 1);
HXDLIN(   8)											_this->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
HXDLIN(   8)										{
HXLINE(   8)											w = (w + 1);
HXDLIN(   8)											_this->data->b[(w - 1)] = ( (unsigned char)(0) );
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(   8)				_hx_tmp = b;
            			}
            			break;
            			case (int)1: {
HXLINE(   8)				 ::iterMagic::ArrIntImg arrI =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(   8)				 ::iterMagic::ArrIntImg a = arrI;
HXDLIN(   8)				{
HXLINE(   8)					 ::iterMagic::ArrIntImg _this1 = a;
HXDLIN(   8)					_this1->width = 100;
HXDLIN(   8)					_this1->height = 100;
HXDLIN(   8)					_this1->data = ::Array_obj< int >::__new(0);
HXDLIN(   8)					_this1->length = 10000;
HXDLIN(   8)					{
HXLINE(   8)						int _g4 = 0;
HXDLIN(   8)						int _g5 = _this1->length;
HXDLIN(   8)						while((_g4 < _g5)){
HXLINE(   8)							_g4 = (_g4 + 1);
HXDLIN(   8)							int i = (_g4 - 1);
HXDLIN(   8)							_this1->data[i] = 0;
            						}
            					}
            				}
HXDLIN(   8)				_hx_tmp = a;
            			}
            			break;
            			case (int)2: {
HXLINE(   8)				 ::iterMagic::U32ArrImg u32a =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(   8)				 ::iterMagic::U32ArrImg b1 = u32a;
HXDLIN(   8)				{
HXLINE(   8)					 ::iterMagic::U32ArrImg _this2 = b1;
HXDLIN(   8)					_this2->width = 100;
HXDLIN(   8)					_this2->height = 100;
HXDLIN(   8)					_this2->length = 10000;
HXDLIN(   8)					int size = (_this2->length * 4);
HXDLIN(   8)					_this2->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size),0,size);
HXDLIN(   8)					{
HXLINE(   8)						int _g6 = 0;
HXDLIN(   8)						int _g7 = _this2->length;
HXDLIN(   8)						while((_g6 < _g7)){
HXLINE(   8)							_g6 = (_g6 + 1);
HXDLIN(   8)							int i1 = (_g6 - 1);
HXDLIN(   8)							{
HXLINE(   8)								 ::haxe::io::ArrayBufferViewImpl this2 = _this2->data;
HXDLIN(   8)								bool _hx_tmp1;
HXDLIN(   8)								if ((i1 >= 0)) {
HXLINE(   8)									_hx_tmp1 = (i1 < (this2->byteLength >> 2));
            								}
            								else {
HXLINE(   8)									_hx_tmp1 = false;
            								}
HXDLIN(   8)								if (_hx_tmp1) {
HXLINE(   8)									 ::haxe::io::Bytes _this3 = this2->bytes;
HXDLIN(   8)									int pos = ((i1 << 2) + this2->byteOffset);
HXDLIN(   8)									_this3->b[pos] = ( (unsigned char)(0) );
HXDLIN(   8)									_this3->b[(pos + 1)] = ( (unsigned char)(0) );
HXDLIN(   8)									_this3->b[(pos + 2)] = ( (unsigned char)(0) );
HXDLIN(   8)									_this3->b[(pos + 3)] = ( (unsigned char)(0) );
            								}
            							}
            						}
            					}
            				}
HXDLIN(   8)				_hx_tmp = b1;
            			}
            			break;
            			case (int)3: {
HXLINE(   8)				 ::iterMagic::U8ArrImg u8a =  ::iterMagic::U8ArrImg_obj::__alloc( HX_CTX );
HXDLIN(   8)				 ::iterMagic::U8ArrImg b2 = u8a;
HXDLIN(   8)				{
HXLINE(   8)					 ::iterMagic::U8ArrImg _this4 = b2;
HXDLIN(   8)					_this4->width = 100;
HXDLIN(   8)					_this4->height = 100;
HXDLIN(   8)					_this4->length = 10000;
HXDLIN(   8)					int elements = (_this4->length * 4);
HXDLIN(   8)					_this4->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(elements),0,elements);
HXDLIN(   8)					{
HXLINE(   8)						int _g8 = 0;
HXDLIN(   8)						int _g9 = (_this4->length * 4);
HXDLIN(   8)						while((_g8 < _g9)){
HXLINE(   8)							_g8 = (_g8 + 1);
HXDLIN(   8)							int i2 = (_g8 - 1);
HXDLIN(   8)							{
HXLINE(   8)								 ::haxe::io::ArrayBufferViewImpl this3 = _this4->data;
HXDLIN(   8)								bool _hx_tmp2;
HXDLIN(   8)								if ((i2 >= 0)) {
HXLINE(   8)									_hx_tmp2 = (i2 < this3->byteLength);
            								}
            								else {
HXLINE(   8)									_hx_tmp2 = false;
            								}
HXDLIN(   8)								if (_hx_tmp2) {
HXLINE(   8)									this3->bytes->b[(i2 + this3->byteOffset)] = ( (unsigned char)(0) );
            								}
            							}
            						}
            					}
            				}
HXDLIN(   8)				_hx_tmp = b2;
            			}
            			break;
            			case (int)4: {
HXLINE(   8)				 ::iterMagic::VecIntImg vec =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(   8)				 ::iterMagic::VecIntImg v = vec;
HXDLIN(   8)				{
HXLINE(   8)					 ::iterMagic::VecIntImg _this5 = v;
HXDLIN(   8)					_this5->width = 100;
HXDLIN(   8)					_this5->height = 100;
HXDLIN(   8)					_this5->length = 10000;
HXDLIN(   8)					_this5->data = ::Array_obj< int >::__new(_this5->length);
HXDLIN(   8)					{
HXLINE(   8)						int _g10 = 0;
HXDLIN(   8)						int _g11 = _this5->length;
HXDLIN(   8)						while((_g10 < _g11)){
HXLINE(   8)							_g10 = (_g10 + 1);
HXDLIN(   8)							int i3 = (_g10 - 1);
HXDLIN(   8)							_this5->data->__unsafe_set(i3,0);
            						}
            					}
            				}
HXDLIN(   8)				_hx_tmp = v;
            			}
            			break;
            			case (int)5: {
HXLINE(   8)				 ::iterMagic::StackIntImg sInt =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(   8)				 ::iterMagic::StackIntImg b3 = sInt;
HXDLIN(   8)				{
HXLINE(   8)					 ::iterMagic::StackIntImg _this6 = b3;
HXDLIN(   8)					_this6->width = 100;
HXDLIN(   8)					_this6->height = 100;
HXDLIN(   8)					_this6->length = 10000;
HXDLIN(   8)					_this6->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(   8)					{
HXLINE(   8)						int len1 = _this6->length;
HXDLIN(   8)						 ::haxe::ds::GenericStack_Int d = _this6->data;
HXDLIN(   8)						if (::hx::IsNull( d->head )) {
HXLINE(   8)							int _g12 = 0;
HXDLIN(   8)							int _g13 = len1;
HXDLIN(   8)							while((_g12 < _g13)){
HXLINE(   8)								_g12 = (_g12 + 1);
HXDLIN(   8)								int i4 = (_g12 - 1);
HXDLIN(   8)								d->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d->head);
            							}
            						}
            						else {
HXLINE(   8)							int _g14 = 0;
HXDLIN(   8)							int _g15 = len1;
HXDLIN(   8)							while((_g14 < _g15)){
HXLINE(   8)								_g14 = (_g14 + 1);
HXDLIN(   8)								int i5 = (_g14 - 1);
HXDLIN(   8)								{
HXLINE(   8)									 ::haxe::ds::GenericCell_Int l = _this6->data->head;
HXDLIN(   8)									 ::haxe::ds::GenericCell_Int prev = null();
HXDLIN(   8)									{
HXLINE(   8)										int _g16 = 0;
HXDLIN(   8)										int _g17 = i5;
HXDLIN(   8)										while((_g16 < _g17)){
HXLINE(   8)											_g16 = (_g16 + 1);
HXDLIN(   8)											int i6 = (_g16 - 1);
HXLINE( 418)											prev = l;
HXLINE( 419)											l = l->next;
            										}
            									}
HXLINE(   8)									if (::hx::IsNull( prev )) {
HXLINE(   8)										_this6->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(   8)										l = null();
            									}
            									else {
HXLINE(   8)										prev->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l->next);
HXDLIN(   8)										l = null();
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(   8)				_hx_tmp = b3;
            			}
            			break;
            		}
HXDLIN(   8)		this1->image = _hx_tmp;
HXDLIN(   8)		this1->width = 100;
HXDLIN(   8)		this1->height = 100;
HXDLIN(   8)		this1->imageType = ( (int)(imageType) );
HXDLIN(   8)		 ::pi_xy::ImageStruct p = this1;
HXLINE(   9)		p->transparent = false;
HXLINE(  10)		int Violet = -7077677;
HXLINE(  11)		int Indigo = -11861886;
HXLINE(  12)		int Blue = -16776961;
HXLINE(  13)		int Green = -16711936;
HXLINE(  14)		int Yellow = -256;
HXLINE(  15)		int Orange = -33024;
HXLINE(  16)		int Red = -65536;
HXLINE(  17)		int scale = 10;
HXLINE(  18)		::Array< int > colors = ::Array_obj< int >::__new(7)->init(0,Violet)->init(1,Indigo)->init(2,Blue)->init(3,Green)->init(4,Yellow)->init(5,Orange)->init(6,Red);
HXLINE(  19)		int vertColor = colors->__get(0);
HXLINE(  20)		{
HXLINE(  20)			int _g18 = 0;
HXDLIN(  20)			while((_g18 < 70)){
HXLINE(  20)				_g18 = (_g18 + 1);
HXDLIN(  20)				int x1 = (_g18 - 1);
HXLINE(  21)				vertColor = colors->__get(::Math_obj::floor((( (Float)(x1) ) / ( (Float)(10) ))));
HXLINE(  22)				{
HXLINE(  22)					int _g19 = 0;
HXDLIN(  22)					while((_g19 < 70)){
HXLINE(  22)						_g19 = (_g19 + 1);
HXDLIN(  22)						int y1 = (_g19 - 1);
HXDLIN(  22)						{
HXLINE(  22)							int c = vertColor;
HXDLIN(  22)							bool _hx_tmp3;
HXDLIN(  22)							if ((((c >> 24) & 255) < 254)) {
HXLINE(  22)								_hx_tmp3 = p->transparent;
            							}
            							else {
HXLINE(  22)								_hx_tmp3 = false;
            							}
HXDLIN(  22)							if (_hx_tmp3) {
HXLINE(  22)								int location;
HXDLIN(  22)								if (p->useVirtualPos) {
HXLINE(  22)									location = ::Std_obj::_hx_int(((((( (Float)(y1) ) - p->virtualY) * ( (Float)(p->width) )) + x1) - p->virtualX));
            								}
            								else {
HXLINE(  22)									location = ::Std_obj::_hx_int(( (Float)(((y1 * p->width) + x1)) ));
            								}
HXDLIN(  22)								int this4 = ::iterMagic::Iimg_obj::get(p->image,location);
HXDLIN(  22)								int this5;
HXDLIN(  22)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  22)									this5 = ((((((this4 >> 24) & 255) << 24) | ((this4 & 255) << 16)) | (((this4 >> 8) & 255) << 8)) | ((this4 >> 16) & 255));
            								}
            								else {
HXLINE(  22)									this5 = this4;
            								}
HXDLIN(  22)								Float a1;
HXDLIN(  22)								int this6 = ((this5 >> 24) & 255);
HXDLIN(  22)								if ((this6 == 0)) {
HXLINE(  22)									a1 = ((Float)0.);
            								}
            								else {
HXLINE(  22)									a1 = (( (Float)(this6) ) / ( (Float)(255) ));
            								}
HXDLIN(  22)								Float r1;
HXDLIN(  22)								int this7 = ((this5 >> 16) & 255);
HXDLIN(  22)								if ((this7 == 0)) {
HXLINE(  22)									r1 = ((Float)0.);
            								}
            								else {
HXLINE(  22)									r1 = (( (Float)(this7) ) / ( (Float)(255) ));
            								}
HXDLIN(  22)								Float g1;
HXDLIN(  22)								int this8 = ((this5 >> 8) & 255);
HXDLIN(  22)								if ((this8 == 0)) {
HXLINE(  22)									g1 = ((Float)0.);
            								}
            								else {
HXLINE(  22)									g1 = (( (Float)(this8) ) / ( (Float)(255) ));
            								}
HXDLIN(  22)								Float b11;
HXDLIN(  22)								int this9 = (this5 & 255);
HXDLIN(  22)								if ((this9 == 0)) {
HXLINE(  22)									b11 = ((Float)0.);
            								}
            								else {
HXLINE(  22)									b11 = (( (Float)(this9) ) / ( (Float)(255) ));
            								}
HXDLIN(  22)								Float a2;
HXDLIN(  22)								int this10 = ((vertColor >> 24) & 255);
HXDLIN(  22)								if ((this10 == 0)) {
HXLINE(  22)									a2 = ((Float)0.);
            								}
            								else {
HXLINE(  22)									a2 = (( (Float)(this10) ) / ( (Float)(255) ));
            								}
HXDLIN(  22)								Float r2;
HXDLIN(  22)								int this11 = ((vertColor >> 16) & 255);
HXDLIN(  22)								if ((this11 == 0)) {
HXLINE(  22)									r2 = ((Float)0.);
            								}
            								else {
HXLINE(  22)									r2 = (( (Float)(this11) ) / ( (Float)(255) ));
            								}
HXDLIN(  22)								Float g2;
HXDLIN(  22)								int this12 = ((vertColor >> 8) & 255);
HXDLIN(  22)								if ((this12 == 0)) {
HXLINE(  22)									g2 = ((Float)0.);
            								}
            								else {
HXLINE(  22)									g2 = (( (Float)(this12) ) / ( (Float)(255) ));
            								}
HXDLIN(  22)								Float b21;
HXDLIN(  22)								int this13 = (vertColor & 255);
HXDLIN(  22)								if ((this13 == 0)) {
HXLINE(  22)									b21 = ((Float)0.);
            								}
            								else {
HXLINE(  22)									b21 = (( (Float)(this13) ) / ( (Float)(255) ));
            								}
HXDLIN(  22)								Float a3 = (a1 * (( (Float)(1) ) - a2));
HXDLIN(  22)								int r = ::Std_obj::_hx_int((( (Float)(255) ) * ((r1 * a3) + (r2 * a2))));
HXDLIN(  22)								int g = ::Std_obj::_hx_int((( (Float)(255) ) * ((g1 * a3) + (g2 * a2))));
HXDLIN(  22)								int b4 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b11 * a3) + (b21 * a2))));
HXDLIN(  22)								int a4 = ::Std_obj::_hx_int((( (Float)(255) ) * (a3 + a2)));
HXDLIN(  22)								int blended = ((((a4 << 24) | (r << 16)) | (g << 8)) | b4);
HXDLIN(  22)								{
HXLINE(  22)									int _hx_tmp4;
HXDLIN(  22)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  22)										_hx_tmp4 = ((((((blended >> 24) & 255) << 24) | ((blended & 255) << 16)) | (((blended >> 8) & 255) << 8)) | ((blended >> 16) & 255));
            									}
            									else {
HXLINE(  22)										_hx_tmp4 = blended;
            									}
HXDLIN(  22)									::iterMagic::Iimg_obj::set(p->image,location,_hx_tmp4);
            								}
            							}
            							else {
HXLINE(  22)								::Dynamic this14 = p->image;
HXDLIN(  22)								int index;
HXDLIN(  22)								if (p->useVirtualPos) {
HXLINE(  22)									index = ::Std_obj::_hx_int(((((( (Float)(y1) ) - p->virtualY) * ( (Float)(p->width) )) + x1) - p->virtualX));
            								}
            								else {
HXLINE(  22)									index = ::Std_obj::_hx_int(( (Float)(((y1 * p->width) + x1)) ));
            								}
HXDLIN(  22)								int _hx_tmp5;
HXDLIN(  22)								if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  22)									_hx_tmp5 = ((((((c >> 24) & 255) << 24) | ((c & 255) << 16)) | (((c >> 8) & 255) << 8)) | ((c >> 16) & 255));
            								}
            								else {
HXLINE(  22)									_hx_tmp5 = c;
            								}
HXDLIN(  22)								::iterMagic::Iimg_obj::set(this14,index,_hx_tmp5);
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE(  24)		{
HXLINE(  24)			 ::pi_xy::ImageStruct this15 = p;
HXDLIN(  24)			{
HXLINE(  24)				bool hasHit = false;
HXDLIN(  24)				bool hasUndo = false;
HXDLIN(  24)				int aA = 240;
HXDLIN(  24)				int rA = 0;
HXDLIN(  24)				int gA = 207;
HXDLIN(  24)				int bA = 255;
HXDLIN(  24)				int aB = 240;
HXDLIN(  24)				int rB = 255;
HXDLIN(  24)				int gB = 207;
HXDLIN(  24)				int bB = 0;
HXDLIN(  24)				int aC = 240;
HXDLIN(  24)				int rC = 207;
HXDLIN(  24)				int gC = 0;
HXDLIN(  24)				int bC = 255;
HXDLIN(  24)				Float bcx = ( (Float)(36) );
HXDLIN(  24)				Float bcy = ( (Float)(-16) );
HXDLIN(  24)				Float acx = ( (Float)(-14) );
HXDLIN(  24)				Float acy = ( (Float)(-50) );
HXDLIN(  24)				Float dot11 = ((bcx * bcx) + (bcy * bcy));
HXDLIN(  24)				Float dot12 = ((bcx * acx) + (bcy * acy));
HXDLIN(  24)				Float dot22 = ((acx * acx) + (acy * acy));
HXDLIN(  24)				Float denom1 = (( (Float)(1) ) / ((dot11 * dot22) - (dot12 * dot12)));
HXDLIN(  24)				int ii_min = ::Math_obj::ceil(( (Float)(10) ));
HXDLIN(  24)				int ii_max = ::Math_obj::ceil(( (Float)(60) ));
HXDLIN(  24)				 ::pi_xy::iter::IntIterStart xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min,ii_max);
HXDLIN(  24)				int ii_min1 = ::Math_obj::floor(( (Float)(10) ));
HXDLIN(  24)				int ii_max1 = ::Math_obj::ceil(( (Float)(60) ));
HXDLIN(  24)				 ::pi_xy::iter::IntIterStart yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min1,ii_max1);
HXDLIN(  24)				 ::pi_xy::ImageStruct undoImage = null();
HXDLIN(  24)				if (hasUndo) {
HXLINE(  24)					int width = ((xIter3->max - xIter3->start) + 1);
HXDLIN(  24)					int height = ((yIter3->max - yIter3->start) + 1);
HXDLIN(  24)					 ::Dynamic imageType1 = null();
HXDLIN(  24)					 ::pi_xy::ImageStruct this16 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  24)					if (::hx::IsNull( imageType1 )) {
HXLINE(  54)						imageType1 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE(  24)					::Dynamic undoImage1;
HXDLIN(  24)					switch((int)(( (int)(imageType1) ))){
            						case (int)0: {
HXLINE(  24)							 ::iterMagic::BytesImg byt1 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  24)							 ::iterMagic::BytesImg b5 = byt1;
HXDLIN(  24)							{
HXLINE(  24)								 ::iterMagic::BytesImg _this7 = b5;
HXDLIN(  24)								_this7->width = width;
HXDLIN(  24)								_this7->height = height;
HXDLIN(  24)								_this7->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  24)								_this7->data = ::haxe::io::Bytes_obj::alloc((_this7->length * 4));
HXDLIN(  24)								{
HXLINE(  24)									int len2 = _this7->length;
HXDLIN(  24)									int w1 = 0;
HXDLIN(  24)									{
HXLINE(  24)										int _g20 = 0;
HXDLIN(  24)										int _g21 = _this7->height;
HXDLIN(  24)										while((_g20 < _g21)){
HXLINE(  24)											_g20 = (_g20 + 1);
HXDLIN(  24)											int y2 = (_g20 - 1);
HXDLIN(  24)											{
HXLINE(  24)												int _g22 = 0;
HXDLIN(  24)												int _g23 = _this7->width;
HXDLIN(  24)												while((_g22 < _g23)){
HXLINE(  24)													_g22 = (_g22 + 1);
HXDLIN(  24)													int x2 = (_g22 - 1);
HXDLIN(  24)													{
HXLINE(  24)														w1 = (w1 + 1);
HXDLIN(  24)														_this7->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  24)													{
HXLINE(  24)														w1 = (w1 + 1);
HXDLIN(  24)														_this7->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  24)													{
HXLINE(  24)														w1 = (w1 + 1);
HXDLIN(  24)														_this7->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  24)													{
HXLINE(  24)														w1 = (w1 + 1);
HXDLIN(  24)														_this7->data->b[(w1 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  24)							undoImage1 = b5;
            						}
            						break;
            						case (int)1: {
HXLINE(  24)							 ::iterMagic::ArrIntImg arrI1 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  24)							 ::iterMagic::ArrIntImg a5 = arrI1;
HXDLIN(  24)							{
HXLINE(  24)								 ::iterMagic::ArrIntImg _this8 = a5;
HXDLIN(  24)								_this8->width = width;
HXDLIN(  24)								_this8->height = height;
HXDLIN(  24)								_this8->data = ::Array_obj< int >::__new(0);
HXDLIN(  24)								_this8->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  24)								{
HXLINE(  24)									int _g24 = 0;
HXDLIN(  24)									int _g25 = _this8->length;
HXDLIN(  24)									while((_g24 < _g25)){
HXLINE(  24)										_g24 = (_g24 + 1);
HXDLIN(  24)										int i7 = (_g24 - 1);
HXDLIN(  24)										_this8->data[i7] = 0;
            									}
            								}
            							}
HXDLIN(  24)							undoImage1 = a5;
            						}
            						break;
            						case (int)2: {
HXLINE(  24)							 ::iterMagic::U32ArrImg u32a1 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  24)							 ::iterMagic::U32ArrImg b6 = u32a1;
HXDLIN(  24)							{
HXLINE(  24)								 ::iterMagic::U32ArrImg _this9 = b6;
HXDLIN(  24)								_this9->width = width;
HXDLIN(  24)								_this9->height = height;
HXDLIN(  24)								_this9->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  24)								int size1 = (_this9->length * 4);
HXDLIN(  24)								_this9->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size1),0,size1);
HXDLIN(  24)								{
HXLINE(  24)									int _g26 = 0;
HXDLIN(  24)									int _g27 = _this9->length;
HXDLIN(  24)									while((_g26 < _g27)){
HXLINE(  24)										_g26 = (_g26 + 1);
HXDLIN(  24)										int i8 = (_g26 - 1);
HXDLIN(  24)										{
HXLINE(  24)											 ::haxe::io::ArrayBufferViewImpl this17 = _this9->data;
HXDLIN(  24)											bool undoImage2;
HXDLIN(  24)											if ((i8 >= 0)) {
HXLINE(  24)												undoImage2 = (i8 < (this17->byteLength >> 2));
            											}
            											else {
HXLINE(  24)												undoImage2 = false;
            											}
HXDLIN(  24)											if (undoImage2) {
HXLINE(  24)												 ::haxe::io::Bytes _this10 = this17->bytes;
HXDLIN(  24)												int pos1 = ((i8 << 2) + this17->byteOffset);
HXDLIN(  24)												_this10->b[pos1] = ( (unsigned char)(0) );
HXDLIN(  24)												_this10->b[(pos1 + 1)] = ( (unsigned char)(0) );
HXDLIN(  24)												_this10->b[(pos1 + 2)] = ( (unsigned char)(0) );
HXDLIN(  24)												_this10->b[(pos1 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN(  24)							undoImage1 = b6;
            						}
            						break;
            						case (int)3: {
HXLINE(  24)							 ::iterMagic::U8ArrImg u8a1 =  ::iterMagic::U8ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  24)							 ::iterMagic::U8ArrImg b7 = u8a1;
HXDLIN(  24)							{
HXLINE(  24)								 ::iterMagic::U8ArrImg _this11 = b7;
HXDLIN(  24)								_this11->width = width;
HXDLIN(  24)								_this11->height = height;
HXDLIN(  24)								_this11->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  24)								int elements1 = (_this11->length * 4);
HXDLIN(  24)								_this11->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(elements1),0,elements1);
HXDLIN(  24)								{
HXLINE(  24)									int _g28 = 0;
HXDLIN(  24)									int _g29 = (_this11->length * 4);
HXDLIN(  24)									while((_g28 < _g29)){
HXLINE(  24)										_g28 = (_g28 + 1);
HXDLIN(  24)										int i9 = (_g28 - 1);
HXDLIN(  24)										{
HXLINE(  24)											 ::haxe::io::ArrayBufferViewImpl this18 = _this11->data;
HXDLIN(  24)											bool undoImage3;
HXDLIN(  24)											if ((i9 >= 0)) {
HXLINE(  24)												undoImage3 = (i9 < this18->byteLength);
            											}
            											else {
HXLINE(  24)												undoImage3 = false;
            											}
HXDLIN(  24)											if (undoImage3) {
HXLINE(  24)												this18->bytes->b[(i9 + this18->byteOffset)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN(  24)							undoImage1 = b7;
            						}
            						break;
            						case (int)4: {
HXLINE(  24)							 ::iterMagic::VecIntImg vec1 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  24)							 ::iterMagic::VecIntImg v1 = vec1;
HXDLIN(  24)							{
HXLINE(  24)								 ::iterMagic::VecIntImg _this12 = v1;
HXDLIN(  24)								_this12->width = width;
HXDLIN(  24)								_this12->height = height;
HXDLIN(  24)								_this12->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  24)								_this12->data = ::Array_obj< int >::__new(_this12->length);
HXDLIN(  24)								{
HXLINE(  24)									int _g30 = 0;
HXDLIN(  24)									int _g31 = _this12->length;
HXDLIN(  24)									while((_g30 < _g31)){
HXLINE(  24)										_g30 = (_g30 + 1);
HXDLIN(  24)										int i10 = (_g30 - 1);
HXDLIN(  24)										_this12->data->__unsafe_set(i10,0);
            									}
            								}
            							}
HXDLIN(  24)							undoImage1 = v1;
            						}
            						break;
            						case (int)5: {
HXLINE(  24)							 ::iterMagic::StackIntImg sInt1 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  24)							 ::iterMagic::StackIntImg b8 = sInt1;
HXDLIN(  24)							{
HXLINE(  24)								 ::iterMagic::StackIntImg _this13 = b8;
HXDLIN(  24)								_this13->width = width;
HXDLIN(  24)								_this13->height = height;
HXDLIN(  24)								_this13->length = ::Std_obj::_hx_int(( (Float)((width * height)) ));
HXDLIN(  24)								_this13->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  24)								{
HXLINE(  24)									int len3 = _this13->length;
HXDLIN(  24)									 ::haxe::ds::GenericStack_Int d1 = _this13->data;
HXDLIN(  24)									if (::hx::IsNull( d1->head )) {
HXLINE(  24)										int _g32 = 0;
HXDLIN(  24)										int _g33 = len3;
HXDLIN(  24)										while((_g32 < _g33)){
HXLINE(  24)											_g32 = (_g32 + 1);
HXDLIN(  24)											int i11 = (_g32 - 1);
HXDLIN(  24)											d1->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d1->head);
            										}
            									}
            									else {
HXLINE(  24)										int _g34 = 0;
HXDLIN(  24)										int _g35 = len3;
HXDLIN(  24)										while((_g34 < _g35)){
HXLINE(  24)											_g34 = (_g34 + 1);
HXDLIN(  24)											int i12 = (_g34 - 1);
HXDLIN(  24)											{
HXLINE(  24)												 ::haxe::ds::GenericCell_Int l1 = _this13->data->head;
HXDLIN(  24)												 ::haxe::ds::GenericCell_Int prev1 = null();
HXDLIN(  24)												{
HXLINE(  24)													int _g36 = 0;
HXDLIN(  24)													int _g37 = i12;
HXDLIN(  24)													while((_g36 < _g37)){
HXLINE(  24)														_g36 = (_g36 + 1);
HXDLIN(  24)														int i13 = (_g36 - 1);
HXLINE( 418)														prev1 = l1;
HXLINE( 419)														l1 = l1->next;
            													}
            												}
HXLINE(  24)												if (::hx::IsNull( prev1 )) {
HXLINE(  24)													_this13->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  24)													l1 = null();
            												}
            												else {
HXLINE(  24)													prev1->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l1->next);
HXDLIN(  24)													l1 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  24)							undoImage1 = b8;
            						}
            						break;
            					}
HXDLIN(  24)					this16->image = undoImage1;
HXDLIN(  24)					this16->width = width;
HXDLIN(  24)					this16->height = height;
HXDLIN(  24)					this16->imageType = ( (int)(imageType1) );
HXDLIN(  24)					undoImage = this16;
HXDLIN(  24)					{
HXLINE(  24)						int rectLeft = xIter3->start;
HXDLIN(  24)						int rectTop = yIter3->start;
HXDLIN(  24)						int rectRight = xIter3->max;
HXDLIN(  24)						bool forceClear = false;
HXDLIN(  24)						{
HXLINE(  24)							int _g38 = rectTop;
HXDLIN(  24)							int _g39 = yIter3->max;
HXDLIN(  24)							while((_g38 < _g39)){
HXLINE(  24)								_g38 = (_g38 + 1);
HXDLIN(  24)								int dy = (_g38 - 1);
HXDLIN(  24)								{
HXLINE(  24)									int _g40 = rectLeft;
HXDLIN(  24)									int _g41 = rectRight;
HXDLIN(  24)									while((_g40 < _g41)){
HXLINE(  24)										_g40 = (_g40 + 1);
HXDLIN(  24)										int dx = (_g40 - 1);
HXDLIN(  24)										::Dynamic this19 = this15->image;
HXDLIN(  24)										int index1;
HXDLIN(  24)										if (this15->useVirtualPos) {
HXLINE(  24)											index1 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this15->virtualY) * ( (Float)(this15->width) )) + dx) - this15->virtualX));
            										}
            										else {
HXLINE(  24)											index1 = ::Std_obj::_hx_int(( (Float)(((dy * this15->width) + dx)) ));
            										}
HXDLIN(  24)										int c1 = ::iterMagic::Iimg_obj::get(this19,index1);
HXDLIN(  24)										int col;
HXDLIN(  24)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  24)											col = ((((((c1 >> 24) & 255) << 24) | ((c1 & 255) << 16)) | (((c1 >> 8) & 255) << 8)) | ((c1 >> 16) & 255));
            										}
            										else {
HXLINE(  24)											col = c1;
            										}
HXDLIN(  24)										bool _hx_tmp6;
HXDLIN(  24)										if (this15->useMask) {
HXLINE(  24)											_hx_tmp6 = ::hx::IsNotNull( this15->mask );
            										}
            										else {
HXLINE(  24)											_hx_tmp6 = false;
            										}
HXDLIN(  24)										if (_hx_tmp6) {
HXLINE(  24)											 ::pi_xy::ImageStruct this20 = this15->mask;
HXDLIN(  24)											::Dynamic this21 = this20->image;
HXDLIN(  24)											int index2;
HXDLIN(  24)											if (this20->useVirtualPos) {
HXLINE(  24)												index2 = ::Std_obj::_hx_int(((((( (Float)(dy) ) - this20->virtualY) * ( (Float)(this20->width) )) + dx) - this20->virtualX));
            											}
            											else {
HXLINE(  24)												index2 = ::Std_obj::_hx_int(( (Float)(((dy * this20->width) + dx)) ));
            											}
HXDLIN(  24)											int c2 = ::iterMagic::Iimg_obj::get(this21,index2);
HXDLIN(  24)											int v2;
HXDLIN(  24)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  24)												v2 = ((((((c2 >> 24) & 255) << 24) | ((c2 & 255) << 16)) | (((c2 >> 8) & 255) << 8)) | ((c2 >> 16) & 255));
            											}
            											else {
HXLINE(  24)												v2 = c2;
            											}
HXDLIN(  24)											int maskPixel = v2;
HXDLIN(  24)											int this22 = col;
HXDLIN(  24)											if ((maskPixel == 0)) {
HXLINE(  24)												col = this22;
            											}
            											else {
HXLINE(  24)												Float m0;
HXDLIN(  24)												int this23 = ((maskPixel >> 24) & 255);
HXDLIN(  24)												if ((this23 == 0)) {
HXLINE(  24)													m0 = ((Float)0.);
            												}
            												else {
HXLINE(  24)													m0 = (( (Float)(this23) ) / ( (Float)(255) ));
            												}
HXDLIN(  24)												Float m1;
HXDLIN(  24)												int this24 = ((maskPixel >> 16) & 255);
HXDLIN(  24)												if ((this24 == 0)) {
HXLINE(  24)													m1 = ((Float)0.);
            												}
            												else {
HXLINE(  24)													m1 = (( (Float)(this24) ) / ( (Float)(255) ));
            												}
HXDLIN(  24)												Float m2;
HXDLIN(  24)												int this25 = ((maskPixel >> 8) & 255);
HXDLIN(  24)												if ((this25 == 0)) {
HXLINE(  24)													m2 = ((Float)0.);
            												}
            												else {
HXLINE(  24)													m2 = (( (Float)(this25) ) / ( (Float)(255) ));
            												}
HXDLIN(  24)												Float m3;
HXDLIN(  24)												int this26 = (maskPixel & 255);
HXDLIN(  24)												if ((this26 == 0)) {
HXLINE(  24)													m3 = ((Float)0.);
            												}
            												else {
HXLINE(  24)													m3 = (( (Float)(this26) ) / ( (Float)(255) ));
            												}
HXDLIN(  24)												int ch0 = ::Std_obj::_hx_int(((((Float)1.) - m0) * ( (Float)(((this22 >> 24) & 255)) )));
HXDLIN(  24)												int ch1 = ::Std_obj::_hx_int(((((Float)1.) - m1) * ( (Float)(((this22 >> 16) & 255)) )));
HXDLIN(  24)												int ch2 = ::Std_obj::_hx_int(((((Float)1.) - m2) * ( (Float)(((this22 >> 8) & 255)) )));
HXDLIN(  24)												int ch3 = ::Std_obj::_hx_int(((((Float)1.) - m3) * ( (Float)((this22 & 255)) )));
HXDLIN(  24)												col = ((((::Math_obj::round((( (Float)(ch0) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch1) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch2) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch3) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN(  24)										if ((col != 0)) {
HXLINE(  24)											int x3 = (dx - rectLeft);
HXDLIN(  24)											int y3 = (dy - rectTop);
HXDLIN(  24)											int c3 = col;
HXDLIN(  24)											bool _hx_tmp7;
HXDLIN(  24)											if ((((c3 >> 24) & 255) < 254)) {
HXLINE(  24)												_hx_tmp7 = undoImage->transparent;
            											}
            											else {
HXLINE(  24)												_hx_tmp7 = false;
            											}
HXDLIN(  24)											if (_hx_tmp7) {
HXLINE(  24)												int location1;
HXDLIN(  24)												if (undoImage->useVirtualPos) {
HXLINE(  24)													location1 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x3) - undoImage->virtualX));
            												}
            												else {
HXLINE(  24)													location1 = ::Std_obj::_hx_int(( (Float)(((y3 * undoImage->width) + x3)) ));
            												}
HXDLIN(  24)												int this27 = ::iterMagic::Iimg_obj::get(undoImage->image,location1);
HXDLIN(  24)												int this28;
HXDLIN(  24)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  24)													this28 = ((((((this27 >> 24) & 255) << 24) | ((this27 & 255) << 16)) | (((this27 >> 8) & 255) << 8)) | ((this27 >> 16) & 255));
            												}
            												else {
HXLINE(  24)													this28 = this27;
            												}
HXDLIN(  24)												Float a11;
HXDLIN(  24)												int this29 = ((this28 >> 24) & 255);
HXDLIN(  24)												if ((this29 == 0)) {
HXLINE(  24)													a11 = ((Float)0.);
            												}
            												else {
HXLINE(  24)													a11 = (( (Float)(this29) ) / ( (Float)(255) ));
            												}
HXDLIN(  24)												Float r11;
HXDLIN(  24)												int this30 = ((this28 >> 16) & 255);
HXDLIN(  24)												if ((this30 == 0)) {
HXLINE(  24)													r11 = ((Float)0.);
            												}
            												else {
HXLINE(  24)													r11 = (( (Float)(this30) ) / ( (Float)(255) ));
            												}
HXDLIN(  24)												Float g11;
HXDLIN(  24)												int this31 = ((this28 >> 8) & 255);
HXDLIN(  24)												if ((this31 == 0)) {
HXLINE(  24)													g11 = ((Float)0.);
            												}
            												else {
HXLINE(  24)													g11 = (( (Float)(this31) ) / ( (Float)(255) ));
            												}
HXDLIN(  24)												Float b12;
HXDLIN(  24)												int this32 = (this28 & 255);
HXDLIN(  24)												if ((this32 == 0)) {
HXLINE(  24)													b12 = ((Float)0.);
            												}
            												else {
HXLINE(  24)													b12 = (( (Float)(this32) ) / ( (Float)(255) ));
            												}
HXDLIN(  24)												Float a21;
HXDLIN(  24)												int this33 = ((col >> 24) & 255);
HXDLIN(  24)												if ((this33 == 0)) {
HXLINE(  24)													a21 = ((Float)0.);
            												}
            												else {
HXLINE(  24)													a21 = (( (Float)(this33) ) / ( (Float)(255) ));
            												}
HXDLIN(  24)												Float r21;
HXDLIN(  24)												int this34 = ((col >> 16) & 255);
HXDLIN(  24)												if ((this34 == 0)) {
HXLINE(  24)													r21 = ((Float)0.);
            												}
            												else {
HXLINE(  24)													r21 = (( (Float)(this34) ) / ( (Float)(255) ));
            												}
HXDLIN(  24)												Float g21;
HXDLIN(  24)												int this35 = ((col >> 8) & 255);
HXDLIN(  24)												if ((this35 == 0)) {
HXLINE(  24)													g21 = ((Float)0.);
            												}
            												else {
HXLINE(  24)													g21 = (( (Float)(this35) ) / ( (Float)(255) ));
            												}
HXDLIN(  24)												Float b22;
HXDLIN(  24)												int this36 = (col & 255);
HXDLIN(  24)												if ((this36 == 0)) {
HXLINE(  24)													b22 = ((Float)0.);
            												}
            												else {
HXLINE(  24)													b22 = (( (Float)(this36) ) / ( (Float)(255) ));
            												}
HXDLIN(  24)												Float a31 = (a11 * (( (Float)(1) ) - a21));
HXDLIN(  24)												int r3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r11 * a31) + (r21 * a21))));
HXDLIN(  24)												int g3 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g11 * a31) + (g21 * a21))));
HXDLIN(  24)												int b9 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b12 * a31) + (b22 * a21))));
HXDLIN(  24)												int a6 = ::Std_obj::_hx_int((( (Float)(255) ) * (a31 + a21)));
HXDLIN(  24)												int blended1 = ((((a6 << 24) | (r3 << 16)) | (g3 << 8)) | b9);
HXDLIN(  24)												{
HXLINE(  24)													int _hx_tmp8;
HXDLIN(  24)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  24)														_hx_tmp8 = ((((((blended1 >> 24) & 255) << 24) | ((blended1 & 255) << 16)) | (((blended1 >> 8) & 255) << 8)) | ((blended1 >> 16) & 255));
            													}
            													else {
HXLINE(  24)														_hx_tmp8 = blended1;
            													}
HXDLIN(  24)													::iterMagic::Iimg_obj::set(undoImage->image,location1,_hx_tmp8);
            												}
            											}
            											else {
HXLINE(  24)												::Dynamic this37 = undoImage->image;
HXDLIN(  24)												int index3;
HXDLIN(  24)												if (undoImage->useVirtualPos) {
HXLINE(  24)													index3 = ::Std_obj::_hx_int(((((( (Float)(y3) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x3) - undoImage->virtualX));
            												}
            												else {
HXLINE(  24)													index3 = ::Std_obj::_hx_int(( (Float)(((y3 * undoImage->width) + x3)) ));
            												}
HXDLIN(  24)												int _hx_tmp9;
HXDLIN(  24)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  24)													_hx_tmp9 = ((((((c3 >> 24) & 255) << 24) | ((c3 & 255) << 16)) | (((c3 >> 8) & 255) << 8)) | ((c3 >> 16) & 255));
            												}
            												else {
HXLINE(  24)													_hx_tmp9 = c3;
            												}
HXDLIN(  24)												::iterMagic::Iimg_obj::set(this37,index3,_hx_tmp9);
            											}
            										}
            										else {
HXLINE(  24)											if (forceClear) {
HXLINE(  24)												::Dynamic this38 = undoImage->image;
HXDLIN(  24)												int x4 = (dx - rectLeft);
HXDLIN(  24)												int y4 = (dy - rectTop);
HXDLIN(  24)												int index4;
HXDLIN(  24)												if (undoImage->useVirtualPos) {
HXLINE(  24)													index4 = ::Std_obj::_hx_int(((((( (Float)(y4) ) - undoImage->virtualY) * ( (Float)(undoImage->width) )) + x4) - undoImage->virtualX));
            												}
            												else {
HXLINE(  24)													index4 = ::Std_obj::_hx_int(( (Float)(((y4 * undoImage->width) + x4)) ));
            												}
HXDLIN(  24)												::iterMagic::Iimg_obj::set(this38,index4,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  24)				{
HXLINE(  24)					int _g_min = xIter3->start;
HXDLIN(  24)					int _g_max = xIter3->max;
HXDLIN(  24)					while((_g_min < _g_max)){
HXLINE(  24)						_g_min = (_g_min + 1);
HXDLIN(  24)						int px = (_g_min - 1);
HXDLIN(  24)						Float pcx = (( (Float)(px) ) - ( (Float)(24) ));
HXDLIN(  24)						{
HXLINE(  24)							int _g_min1 = yIter3->start;
HXDLIN(  24)							int _g_max1 = yIter3->max;
HXDLIN(  24)							while((_g_min1 < _g_max1)){
HXLINE(  24)								_g_min1 = (_g_min1 + 1);
HXDLIN(  24)								int py = (_g_min1 - 1);
HXDLIN(  24)								Float pcy = (( (Float)(py) ) - ( (Float)(60) ));
HXDLIN(  24)								Float dot31 = ((pcx * bcx) + (pcy * bcy));
HXDLIN(  24)								Float dot32 = ((pcx * acx) + (pcy * acy));
HXDLIN(  24)								Float ratioA = (((dot22 * dot31) - (dot12 * dot32)) * denom1);
HXDLIN(  24)								Float ratioB = (((dot11 * dot32) - (dot12 * dot31)) * denom1);
HXDLIN(  24)								Float ratioC = ((((Float)1.0) - ratioB) - ratioA);
HXDLIN(  24)								bool _hx_tmp10;
HXDLIN(  24)								bool _hx_tmp11;
HXDLIN(  24)								if ((ratioA >= 0)) {
HXLINE(  24)									_hx_tmp11 = (ratioB >= 0);
            								}
            								else {
HXLINE(  24)									_hx_tmp11 = false;
            								}
HXDLIN(  24)								if (_hx_tmp11) {
HXLINE(  24)									_hx_tmp10 = (ratioC >= 0);
            								}
            								else {
HXLINE(  24)									_hx_tmp10 = false;
            								}
HXDLIN(  24)								if (_hx_tmp10) {
HXLINE(  24)									int i14 = ::Std_obj::_hx_int((((( (Float)(aA) ) * ratioA) + (( (Float)(aB) ) * ratioB)) + (( (Float)(aC) ) * ratioC)));
HXDLIN(  24)									if ((i14 > 255)) {
HXLINE(  24)										i14 = 255;
            									}
HXDLIN(  24)									if ((i14 < 0)) {
HXLINE(  25)										i14 = 0;
            									}
HXLINE(  24)									int a7 = i14;
HXDLIN(  24)									int i15 = ::Std_obj::_hx_int((((( (Float)(rA) ) * ratioA) + (( (Float)(rB) ) * ratioB)) + (( (Float)(rC) ) * ratioC)));
HXDLIN(  24)									if ((i15 > 255)) {
HXLINE(  24)										i15 = 255;
            									}
HXDLIN(  24)									if ((i15 < 0)) {
HXLINE(  25)										i15 = 0;
            									}
HXLINE(  24)									int r4 = i15;
HXDLIN(  24)									int i16 = ::Std_obj::_hx_int((((( (Float)(gA) ) * ratioA) + (( (Float)(gB) ) * ratioB)) + (( (Float)(gC) ) * ratioC)));
HXDLIN(  24)									if ((i16 > 255)) {
HXLINE(  24)										i16 = 255;
            									}
HXDLIN(  24)									if ((i16 < 0)) {
HXLINE(  25)										i16 = 0;
            									}
HXLINE(  24)									int g4 = i16;
HXDLIN(  24)									int i17 = ::Std_obj::_hx_int((((( (Float)(bA) ) * ratioA) + (( (Float)(bB) ) * ratioB)) + (( (Float)(bC) ) * ratioC)));
HXDLIN(  24)									if ((i17 > 255)) {
HXLINE(  24)										i17 = 255;
            									}
HXDLIN(  24)									if ((i17 < 0)) {
HXLINE(  25)										i17 = 0;
            									}
HXLINE(  24)									int b10 = i17;
HXDLIN(  24)									{
HXLINE(  24)										int location2;
HXDLIN(  24)										if (this15->useVirtualPos) {
HXLINE(  24)											location2 = ::Std_obj::_hx_int(((((( (Float)(py) ) - this15->virtualY) * ( (Float)(this15->width) )) + px) - this15->virtualX));
            										}
            										else {
HXLINE(  24)											location2 = ::Std_obj::_hx_int(( (Float)(((py * this15->width) + px)) ));
            										}
HXDLIN(  24)										bool _hx_tmp12;
HXDLIN(  24)										if (this15->transparent) {
HXLINE(  24)											_hx_tmp12 = (a7 < 254);
            										}
            										else {
HXLINE(  24)											_hx_tmp12 = false;
            										}
HXDLIN(  24)										if (_hx_tmp12) {
HXLINE(  24)											int this39 = ::iterMagic::Iimg_obj::get(this15->image,location2);
HXDLIN(  24)											int old;
HXDLIN(  24)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  24)												old = ((((((this39 >> 24) & 255) << 24) | ((this39 & 255) << 16)) | (((this39 >> 8) & 255) << 8)) | ((this39 >> 16) & 255));
            											}
            											else {
HXLINE(  24)												old = this39;
            											}
HXDLIN(  24)											int rhs = ((((a7 << 24) | (r4 << 16)) | (g4 << 8)) | b10);
HXDLIN(  24)											Float a12;
HXDLIN(  24)											int this40 = ((old >> 24) & 255);
HXDLIN(  24)											if ((this40 == 0)) {
HXLINE(  24)												a12 = ((Float)0.);
            											}
            											else {
HXLINE(  24)												a12 = (( (Float)(this40) ) / ( (Float)(255) ));
            											}
HXDLIN(  24)											Float r12;
HXDLIN(  24)											int this41 = ((old >> 16) & 255);
HXDLIN(  24)											if ((this41 == 0)) {
HXLINE(  24)												r12 = ((Float)0.);
            											}
            											else {
HXLINE(  24)												r12 = (( (Float)(this41) ) / ( (Float)(255) ));
            											}
HXDLIN(  24)											Float g12;
HXDLIN(  24)											int this42 = ((old >> 8) & 255);
HXDLIN(  24)											if ((this42 == 0)) {
HXLINE(  24)												g12 = ((Float)0.);
            											}
            											else {
HXLINE(  24)												g12 = (( (Float)(this42) ) / ( (Float)(255) ));
            											}
HXDLIN(  24)											Float b13;
HXDLIN(  24)											int this43 = (old & 255);
HXDLIN(  24)											if ((this43 == 0)) {
HXLINE(  24)												b13 = ((Float)0.);
            											}
            											else {
HXLINE(  24)												b13 = (( (Float)(this43) ) / ( (Float)(255) ));
            											}
HXDLIN(  24)											Float a22;
HXDLIN(  24)											int this44 = ((rhs >> 24) & 255);
HXDLIN(  24)											if ((this44 == 0)) {
HXLINE(  24)												a22 = ((Float)0.);
            											}
            											else {
HXLINE(  24)												a22 = (( (Float)(this44) ) / ( (Float)(255) ));
            											}
HXDLIN(  24)											Float r22;
HXDLIN(  24)											int this45 = ((rhs >> 16) & 255);
HXDLIN(  24)											if ((this45 == 0)) {
HXLINE(  24)												r22 = ((Float)0.);
            											}
            											else {
HXLINE(  24)												r22 = (( (Float)(this45) ) / ( (Float)(255) ));
            											}
HXDLIN(  24)											Float g22;
HXDLIN(  24)											int this46 = ((rhs >> 8) & 255);
HXDLIN(  24)											if ((this46 == 0)) {
HXLINE(  24)												g22 = ((Float)0.);
            											}
            											else {
HXLINE(  24)												g22 = (( (Float)(this46) ) / ( (Float)(255) ));
            											}
HXDLIN(  24)											Float b23;
HXDLIN(  24)											int this47 = (rhs & 255);
HXDLIN(  24)											if ((this47 == 0)) {
HXLINE(  24)												b23 = ((Float)0.);
            											}
            											else {
HXLINE(  24)												b23 = (( (Float)(this47) ) / ( (Float)(255) ));
            											}
HXDLIN(  24)											Float a32 = (a12 * (( (Float)(1) ) - a22));
HXDLIN(  24)											int r5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r12 * a32) + (r22 * a22))));
HXDLIN(  24)											int g5 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g12 * a32) + (g22 * a22))));
HXDLIN(  24)											int b14 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b13 * a32) + (b23 * a22))));
HXDLIN(  24)											int a8 = ::Std_obj::_hx_int((( (Float)(255) ) * (a32 + a22)));
HXDLIN(  24)											int blended2 = ((((a8 << 24) | (r5 << 16)) | (g5 << 8)) | b14);
HXDLIN(  24)											{
HXLINE(  24)												int _hx_tmp13;
HXDLIN(  24)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  24)													_hx_tmp13 = ((((((blended2 >> 24) & 255) << 24) | ((blended2 & 255) << 16)) | (((blended2 >> 8) & 255) << 8)) | ((blended2 >> 16) & 255));
            												}
            												else {
HXLINE(  24)													_hx_tmp13 = blended2;
            												}
HXDLIN(  24)												::iterMagic::Iimg_obj::set(this15->image,location2,_hx_tmp13);
            											}
            										}
            										else {
HXLINE(  24)											int value;
HXDLIN(  24)											if (this15->isLittle) {
HXLINE(  24)												value = ((((a7 << 24) | (b10 << 16)) | (g4 << 8)) | r4);
            											}
            											else {
HXLINE(  24)												value = ((((a7 << 24) | (r4 << 16)) | (g4 << 8)) | b10);
            											}
HXDLIN(  24)											::iterMagic::Iimg_obj::set(this15->image,location2,value);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  24)				if ((hasHit == false)) {
HXLINE(  24)					 ::pi_xy::iter::IntIterStart v_yIter3;
HXDLIN(  24)					 ::pi_xy::iter::IntIterStart v_xIter3;
HXDLIN(  24)					int v_undoY;
HXDLIN(  24)					int v_undoX;
HXDLIN(  24)					Float v_ty;
HXDLIN(  24)					Float v_tx;
HXDLIN(  24)					Float v_t0;
HXDLIN(  24)					Float v_sy;
HXDLIN(  24)					Float v_sx;
HXDLIN(  24)					Float v_s0;
HXDLIN(  24)					Float v_A;
HXDLIN(  24)					 ::pi_xy::ImageStruct v_undoImage = null();
HXDLIN(  24)					Float bx = ( (Float)(60) );
HXDLIN(  24)					Float by = ( (Float)(44) );
HXDLIN(  24)					Float cx = ( (Float)(24) );
HXDLIN(  24)					Float cy = ( (Float)(60) );
HXDLIN(  24)					bool adjustWinding = (((((( (Float)(10) ) * by) - (bx * ( (Float)(10) ))) + ((bx * cy) - (cx * by))) + ((cx * ( (Float)(10) )) - (( (Float)(10) ) * cy))) > 0);
HXDLIN(  24)					if (!(adjustWinding)) {
HXLINE(  24)						Float bx_ = bx;
HXDLIN(  24)						Float by_ = by;
HXDLIN(  24)						bx = cx;
HXLINE(  25)						by = cy;
HXLINE(  26)						cx = bx_;
HXLINE(  27)						cy = by_;
            					}
HXLINE(  24)					Float v_ax = ( (Float)(10) );
HXDLIN(  24)					Float v_ay = ( (Float)(10) );
HXDLIN(  24)					Float v_bx = bx;
HXDLIN(  24)					Float v_by = by;
HXDLIN(  24)					Float v_cx = cx;
HXDLIN(  24)					Float v_cy = cy;
HXDLIN(  24)					bool v_preCalculated = true;
HXDLIN(  24)					{
HXLINE(  24)						v_s0 = ((v_ay * v_cx) - (v_ax * v_cy));
HXDLIN(  24)						v_sx = (v_cy - v_ay);
HXDLIN(  24)						v_sy = (v_ax - v_cx);
HXDLIN(  24)						v_t0 = ((v_ax * v_by) - (v_ay * v_bx));
HXDLIN(  24)						v_tx = (v_ay - v_by);
HXDLIN(  24)						v_ty = (v_bx - v_ax);
HXDLIN(  24)						v_A = ((((-(v_by) * v_cx) + (v_ay * (-(v_bx) + v_cx))) + (v_ax * (v_by - v_cy))) + (v_bx * v_cy));
HXDLIN(  24)						Float a9 = v_ax;
HXDLIN(  24)						Float b15 = v_bx;
HXDLIN(  24)						Float c4 = v_cx;
HXDLIN(  24)						if ((a9 > b15)) {
HXLINE(  24)							if ((a9 > c4)) {
HXLINE(  24)								int min;
HXDLIN(  24)								if ((b15 > c4)) {
HXLINE(  24)									min = ::Math_obj::floor(c4);
            								}
            								else {
HXLINE(  24)									min = ::Math_obj::floor(b15);
            								}
HXDLIN(  24)								int ii_min2 = min;
HXDLIN(  24)								int ii_max2 = ::Math_obj::ceil(a9);
HXDLIN(  24)								v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min2,ii_max2);
            							}
            							else {
HXLINE(  24)								int ii_min3 = ::Math_obj::floor(b15);
HXDLIN(  24)								int ii_max3 = ::Math_obj::ceil(c4);
HXDLIN(  24)								v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min3,ii_max3);
            							}
            						}
            						else {
HXLINE(  24)							if ((b15 > c4)) {
HXLINE(  24)								int min1;
HXDLIN(  24)								if ((a9 > c4)) {
HXLINE(  24)									min1 = ::Math_obj::floor(c4);
            								}
            								else {
HXLINE(  24)									min1 = ::Math_obj::ceil(a9);
            								}
HXDLIN(  24)								int ii_min4 = min1;
HXDLIN(  24)								int ii_max4 = ::Math_obj::ceil(b15);
HXDLIN(  24)								v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min4,ii_max4);
            							}
            							else {
HXLINE(  24)								int ii_min5 = ::Math_obj::floor(a9);
HXDLIN(  24)								int ii_max5 = ::Math_obj::ceil(c4);
HXDLIN(  24)								v_xIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min5,ii_max5);
            							}
            						}
HXDLIN(  24)						Float a10 = v_ay;
HXDLIN(  24)						Float b16 = v_by;
HXDLIN(  24)						Float c5 = v_cy;
HXDLIN(  24)						if ((a10 > b16)) {
HXLINE(  24)							if ((a10 > c5)) {
HXLINE(  24)								int min2;
HXDLIN(  24)								if ((b16 > c5)) {
HXLINE(  24)									min2 = ::Math_obj::floor(c5);
            								}
            								else {
HXLINE(  24)									min2 = ::Math_obj::floor(b16);
            								}
HXDLIN(  24)								int ii_min6 = min2;
HXDLIN(  24)								int ii_max6 = ::Math_obj::ceil(a10);
HXDLIN(  24)								v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min6,ii_max6);
            							}
            							else {
HXLINE(  24)								int ii_min7 = ::Math_obj::floor(b16);
HXDLIN(  24)								int ii_max7 = ::Math_obj::ceil(c5);
HXDLIN(  24)								v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min7,ii_max7);
            							}
            						}
            						else {
HXLINE(  24)							if ((b16 > c5)) {
HXLINE(  24)								int min3;
HXDLIN(  24)								if ((a10 > c5)) {
HXLINE(  24)									min3 = ::Math_obj::floor(c5);
            								}
            								else {
HXLINE(  24)									min3 = ::Math_obj::ceil(a10);
            								}
HXDLIN(  24)								int ii_min8 = min3;
HXDLIN(  24)								int ii_max8 = ::Math_obj::ceil(b16);
HXDLIN(  24)								v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min8,ii_max8);
            							}
            							else {
HXLINE(  24)								int ii_min9 = ::Math_obj::floor(a10);
HXDLIN(  24)								int ii_max9 = ::Math_obj::ceil(c5);
HXDLIN(  24)								v_yIter3 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min9,ii_max9);
            							}
            						}
            					}
HXDLIN(  24)					if (hasUndo) {
HXLINE(  24)						v_undoImage = undoImage;
HXDLIN(  24)						v_undoX = xIter3->start;
HXDLIN(  24)						v_undoY = yIter3->start;
            					}
            				}
            			}
            		}
HXLINE(  25)		{
HXLINE(  25)			 ::pi_xy::ImageStruct this48 = p;
HXDLIN(  25)			{
HXLINE(  25)				bool hasHit1 = false;
HXDLIN(  25)				bool hasUndo1 = false;
HXDLIN(  25)				int aA1 = 204;
HXDLIN(  25)				int rA1 = 0;
HXDLIN(  25)				int gA1 = 0;
HXDLIN(  25)				int bA1 = 255;
HXDLIN(  25)				int aB1 = 204;
HXDLIN(  25)				int rB1 = 255;
HXDLIN(  25)				int gB1 = 0;
HXDLIN(  25)				int bB1 = 0;
HXDLIN(  25)				int aC1 = 204;
HXDLIN(  25)				int rC1 = 0;
HXDLIN(  25)				int gC1 = 255;
HXDLIN(  25)				int bC1 = 0;
HXDLIN(  25)				Float bcx1 = ( (Float)(42) );
HXDLIN(  25)				Float bcy1 = ( (Float)(-4) );
HXDLIN(  25)				Float acx1 = ( (Float)(-6) );
HXDLIN(  25)				Float acy1 = ( (Float)(-41) );
HXDLIN(  25)				Float dot111 = ((bcx1 * bcx1) + (bcy1 * bcy1));
HXDLIN(  25)				Float dot121 = ((bcx1 * acx1) + (bcy1 * acy1));
HXDLIN(  25)				Float dot221 = ((acx1 * acx1) + (acy1 * acy1));
HXDLIN(  25)				Float denom11 = (( (Float)(1) ) / ((dot111 * dot221) - (dot121 * dot121)));
HXDLIN(  25)				int ii_min10 = ::Math_obj::ceil(( (Float)(22) ));
HXDLIN(  25)				int ii_max10 = ::Math_obj::ceil(( (Float)(70) ));
HXDLIN(  25)				 ::pi_xy::iter::IntIterStart xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min10,ii_max10);
HXDLIN(  25)				int ii_min11 = ::Math_obj::floor(( (Float)(23) ));
HXDLIN(  25)				int ii_max11 = ::Math_obj::ceil(( (Float)(64) ));
HXDLIN(  25)				 ::pi_xy::iter::IntIterStart yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min11,ii_max11);
HXDLIN(  25)				 ::pi_xy::ImageStruct undoImage4 = null();
HXDLIN(  25)				if (hasUndo1) {
HXLINE(  25)					int width1 = ((xIter31->max - xIter31->start) + 1);
HXDLIN(  25)					int height1 = ((yIter31->max - yIter31->start) + 1);
HXDLIN(  25)					 ::Dynamic imageType2 = null();
HXDLIN(  25)					 ::pi_xy::ImageStruct this49 =  ::pi_xy::ImageStruct_obj::__alloc( HX_CTX );
HXDLIN(  25)					if (::hx::IsNull( imageType2 )) {
HXLINE(  54)						imageType2 = ::pi_xy::ImageStruct_obj::defaultType;
            					}
HXLINE(  25)					::Dynamic undoImage5;
HXDLIN(  25)					switch((int)(( (int)(imageType2) ))){
            						case (int)0: {
HXLINE(  25)							 ::iterMagic::BytesImg byt2 =  ::iterMagic::BytesImg_obj::__alloc( HX_CTX );
HXDLIN(  25)							 ::iterMagic::BytesImg b17 = byt2;
HXDLIN(  25)							{
HXLINE(  25)								 ::iterMagic::BytesImg _this14 = b17;
HXDLIN(  25)								_this14->width = width1;
HXDLIN(  25)								_this14->height = height1;
HXDLIN(  25)								_this14->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  25)								_this14->data = ::haxe::io::Bytes_obj::alloc((_this14->length * 4));
HXDLIN(  25)								{
HXLINE(  25)									int len4 = _this14->length;
HXDLIN(  25)									int w2 = 0;
HXDLIN(  25)									{
HXLINE(  25)										int _g42 = 0;
HXDLIN(  25)										int _g43 = _this14->height;
HXDLIN(  25)										while((_g42 < _g43)){
HXLINE(  25)											_g42 = (_g42 + 1);
HXDLIN(  25)											int y5 = (_g42 - 1);
HXDLIN(  25)											{
HXLINE(  25)												int _g44 = 0;
HXDLIN(  25)												int _g45 = _this14->width;
HXDLIN(  25)												while((_g44 < _g45)){
HXLINE(  25)													_g44 = (_g44 + 1);
HXDLIN(  25)													int x5 = (_g44 - 1);
HXDLIN(  25)													{
HXLINE(  25)														w2 = (w2 + 1);
HXDLIN(  25)														_this14->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  25)													{
HXLINE(  25)														w2 = (w2 + 1);
HXDLIN(  25)														_this14->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  25)													{
HXLINE(  25)														w2 = (w2 + 1);
HXDLIN(  25)														_this14->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            													}
HXDLIN(  25)													{
HXLINE(  25)														w2 = (w2 + 1);
HXDLIN(  25)														_this14->data->b[(w2 - 1)] = ( (unsigned char)(0) );
            													}
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  25)							undoImage5 = b17;
            						}
            						break;
            						case (int)1: {
HXLINE(  25)							 ::iterMagic::ArrIntImg arrI2 =  ::iterMagic::ArrIntImg_obj::__alloc( HX_CTX );
HXDLIN(  25)							 ::iterMagic::ArrIntImg a13 = arrI2;
HXDLIN(  25)							{
HXLINE(  25)								 ::iterMagic::ArrIntImg _this15 = a13;
HXDLIN(  25)								_this15->width = width1;
HXDLIN(  25)								_this15->height = height1;
HXDLIN(  25)								_this15->data = ::Array_obj< int >::__new(0);
HXDLIN(  25)								_this15->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  25)								{
HXLINE(  25)									int _g46 = 0;
HXDLIN(  25)									int _g47 = _this15->length;
HXDLIN(  25)									while((_g46 < _g47)){
HXLINE(  25)										_g46 = (_g46 + 1);
HXDLIN(  25)										int i18 = (_g46 - 1);
HXDLIN(  25)										_this15->data[i18] = 0;
            									}
            								}
            							}
HXDLIN(  25)							undoImage5 = a13;
            						}
            						break;
            						case (int)2: {
HXLINE(  25)							 ::iterMagic::U32ArrImg u32a2 =  ::iterMagic::U32ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  25)							 ::iterMagic::U32ArrImg b18 = u32a2;
HXDLIN(  25)							{
HXLINE(  25)								 ::iterMagic::U32ArrImg _this16 = b18;
HXDLIN(  25)								_this16->width = width1;
HXDLIN(  25)								_this16->height = height1;
HXDLIN(  25)								_this16->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  25)								int size2 = (_this16->length * 4);
HXDLIN(  25)								_this16->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(size2),0,size2);
HXDLIN(  25)								{
HXLINE(  25)									int _g48 = 0;
HXDLIN(  25)									int _g49 = _this16->length;
HXDLIN(  25)									while((_g48 < _g49)){
HXLINE(  25)										_g48 = (_g48 + 1);
HXDLIN(  25)										int i19 = (_g48 - 1);
HXDLIN(  25)										{
HXLINE(  25)											 ::haxe::io::ArrayBufferViewImpl this50 = _this16->data;
HXDLIN(  25)											bool undoImage6;
HXDLIN(  25)											if ((i19 >= 0)) {
HXLINE(  25)												undoImage6 = (i19 < (this50->byteLength >> 2));
            											}
            											else {
HXLINE(  25)												undoImage6 = false;
            											}
HXDLIN(  25)											if (undoImage6) {
HXLINE(  25)												 ::haxe::io::Bytes _this17 = this50->bytes;
HXDLIN(  25)												int pos2 = ((i19 << 2) + this50->byteOffset);
HXDLIN(  25)												_this17->b[pos2] = ( (unsigned char)(0) );
HXDLIN(  25)												_this17->b[(pos2 + 1)] = ( (unsigned char)(0) );
HXDLIN(  25)												_this17->b[(pos2 + 2)] = ( (unsigned char)(0) );
HXDLIN(  25)												_this17->b[(pos2 + 3)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN(  25)							undoImage5 = b18;
            						}
            						break;
            						case (int)3: {
HXLINE(  25)							 ::iterMagic::U8ArrImg u8a2 =  ::iterMagic::U8ArrImg_obj::__alloc( HX_CTX );
HXDLIN(  25)							 ::iterMagic::U8ArrImg b19 = u8a2;
HXDLIN(  25)							{
HXLINE(  25)								 ::iterMagic::U8ArrImg _this18 = b19;
HXDLIN(  25)								_this18->width = width1;
HXDLIN(  25)								_this18->height = height1;
HXDLIN(  25)								_this18->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  25)								int elements2 = (_this18->length * 4);
HXDLIN(  25)								_this18->data =  ::haxe::io::ArrayBufferViewImpl_obj::__alloc( HX_CTX ,::haxe::io::Bytes_obj::alloc(elements2),0,elements2);
HXDLIN(  25)								{
HXLINE(  25)									int _g50 = 0;
HXDLIN(  25)									int _g51 = (_this18->length * 4);
HXDLIN(  25)									while((_g50 < _g51)){
HXLINE(  25)										_g50 = (_g50 + 1);
HXDLIN(  25)										int i20 = (_g50 - 1);
HXDLIN(  25)										{
HXLINE(  25)											 ::haxe::io::ArrayBufferViewImpl this51 = _this18->data;
HXDLIN(  25)											bool undoImage7;
HXDLIN(  25)											if ((i20 >= 0)) {
HXLINE(  25)												undoImage7 = (i20 < this51->byteLength);
            											}
            											else {
HXLINE(  25)												undoImage7 = false;
            											}
HXDLIN(  25)											if (undoImage7) {
HXLINE(  25)												this51->bytes->b[(i20 + this51->byteOffset)] = ( (unsigned char)(0) );
            											}
            										}
            									}
            								}
            							}
HXDLIN(  25)							undoImage5 = b19;
            						}
            						break;
            						case (int)4: {
HXLINE(  25)							 ::iterMagic::VecIntImg vec2 =  ::iterMagic::VecIntImg_obj::__alloc( HX_CTX );
HXDLIN(  25)							 ::iterMagic::VecIntImg v3 = vec2;
HXDLIN(  25)							{
HXLINE(  25)								 ::iterMagic::VecIntImg _this19 = v3;
HXDLIN(  25)								_this19->width = width1;
HXDLIN(  25)								_this19->height = height1;
HXDLIN(  25)								_this19->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  25)								_this19->data = ::Array_obj< int >::__new(_this19->length);
HXDLIN(  25)								{
HXLINE(  25)									int _g52 = 0;
HXDLIN(  25)									int _g53 = _this19->length;
HXDLIN(  25)									while((_g52 < _g53)){
HXLINE(  25)										_g52 = (_g52 + 1);
HXDLIN(  25)										int i21 = (_g52 - 1);
HXDLIN(  25)										_this19->data->__unsafe_set(i21,0);
            									}
            								}
            							}
HXDLIN(  25)							undoImage5 = v3;
            						}
            						break;
            						case (int)5: {
HXLINE(  25)							 ::iterMagic::StackIntImg sInt2 =  ::iterMagic::StackIntImg_obj::__alloc( HX_CTX );
HXDLIN(  25)							 ::iterMagic::StackIntImg b20 = sInt2;
HXDLIN(  25)							{
HXLINE(  25)								 ::iterMagic::StackIntImg _this20 = b20;
HXDLIN(  25)								_this20->width = width1;
HXDLIN(  25)								_this20->height = height1;
HXDLIN(  25)								_this20->length = ::Std_obj::_hx_int(( (Float)((width1 * height1)) ));
HXDLIN(  25)								_this20->data =  ::haxe::ds::GenericStack_Int_obj::__alloc( HX_CTX );
HXDLIN(  25)								{
HXLINE(  25)									int len5 = _this20->length;
HXDLIN(  25)									 ::haxe::ds::GenericStack_Int d2 = _this20->data;
HXDLIN(  25)									if (::hx::IsNull( d2->head )) {
HXLINE(  25)										int _g54 = 0;
HXDLIN(  25)										int _g55 = len5;
HXDLIN(  25)										while((_g54 < _g55)){
HXLINE(  25)											_g54 = (_g54 + 1);
HXDLIN(  25)											int i22 = (_g54 - 1);
HXDLIN(  25)											d2->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,d2->head);
            										}
            									}
            									else {
HXLINE(  25)										int _g56 = 0;
HXDLIN(  25)										int _g57 = len5;
HXDLIN(  25)										while((_g56 < _g57)){
HXLINE(  25)											_g56 = (_g56 + 1);
HXDLIN(  25)											int i23 = (_g56 - 1);
HXDLIN(  25)											{
HXLINE(  25)												 ::haxe::ds::GenericCell_Int l2 = _this20->data->head;
HXDLIN(  25)												 ::haxe::ds::GenericCell_Int prev2 = null();
HXDLIN(  25)												{
HXLINE(  25)													int _g58 = 0;
HXDLIN(  25)													int _g59 = i23;
HXDLIN(  25)													while((_g58 < _g59)){
HXLINE(  25)														_g58 = (_g58 + 1);
HXDLIN(  25)														int i24 = (_g58 - 1);
HXLINE( 418)														prev2 = l2;
HXLINE( 419)														l2 = l2->next;
            													}
            												}
HXLINE(  25)												if (::hx::IsNull( prev2 )) {
HXLINE(  25)													_this20->data->head =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN(  25)													l2 = null();
            												}
            												else {
HXLINE(  25)													prev2->next =  ::haxe::ds::GenericCell_Int_obj::__alloc( HX_CTX ,0,l2->next);
HXDLIN(  25)													l2 = null();
            												}
            											}
            										}
            									}
            								}
            							}
HXDLIN(  25)							undoImage5 = b20;
            						}
            						break;
            					}
HXDLIN(  25)					this49->image = undoImage5;
HXDLIN(  25)					this49->width = width1;
HXDLIN(  25)					this49->height = height1;
HXDLIN(  25)					this49->imageType = ( (int)(imageType2) );
HXDLIN(  25)					undoImage4 = this49;
HXDLIN(  25)					{
HXLINE(  25)						int rectLeft1 = xIter31->start;
HXDLIN(  25)						int rectTop1 = yIter31->start;
HXDLIN(  25)						int rectRight1 = xIter31->max;
HXDLIN(  25)						bool forceClear1 = false;
HXDLIN(  25)						{
HXLINE(  25)							int _g60 = rectTop1;
HXDLIN(  25)							int _g61 = yIter31->max;
HXDLIN(  25)							while((_g60 < _g61)){
HXLINE(  25)								_g60 = (_g60 + 1);
HXDLIN(  25)								int dy1 = (_g60 - 1);
HXDLIN(  25)								{
HXLINE(  25)									int _g62 = rectLeft1;
HXDLIN(  25)									int _g63 = rectRight1;
HXDLIN(  25)									while((_g62 < _g63)){
HXLINE(  25)										_g62 = (_g62 + 1);
HXDLIN(  25)										int dx1 = (_g62 - 1);
HXDLIN(  25)										::Dynamic this52 = this48->image;
HXDLIN(  25)										int index5;
HXDLIN(  25)										if (this48->useVirtualPos) {
HXLINE(  25)											index5 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this48->virtualY) * ( (Float)(this48->width) )) + dx1) - this48->virtualX));
            										}
            										else {
HXLINE(  25)											index5 = ::Std_obj::_hx_int(( (Float)(((dy1 * this48->width) + dx1)) ));
            										}
HXDLIN(  25)										int c6 = ::iterMagic::Iimg_obj::get(this52,index5);
HXDLIN(  25)										int col1;
HXDLIN(  25)										if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  25)											col1 = ((((((c6 >> 24) & 255) << 24) | ((c6 & 255) << 16)) | (((c6 >> 8) & 255) << 8)) | ((c6 >> 16) & 255));
            										}
            										else {
HXLINE(  25)											col1 = c6;
            										}
HXDLIN(  25)										bool _hx_tmp14;
HXDLIN(  25)										if (this48->useMask) {
HXLINE(  25)											_hx_tmp14 = ::hx::IsNotNull( this48->mask );
            										}
            										else {
HXLINE(  25)											_hx_tmp14 = false;
            										}
HXDLIN(  25)										if (_hx_tmp14) {
HXLINE(  25)											 ::pi_xy::ImageStruct this53 = this48->mask;
HXDLIN(  25)											::Dynamic this54 = this53->image;
HXDLIN(  25)											int index6;
HXDLIN(  25)											if (this53->useVirtualPos) {
HXLINE(  25)												index6 = ::Std_obj::_hx_int(((((( (Float)(dy1) ) - this53->virtualY) * ( (Float)(this53->width) )) + dx1) - this53->virtualX));
            											}
            											else {
HXLINE(  25)												index6 = ::Std_obj::_hx_int(( (Float)(((dy1 * this53->width) + dx1)) ));
            											}
HXDLIN(  25)											int c7 = ::iterMagic::Iimg_obj::get(this54,index6);
HXDLIN(  25)											int v4;
HXDLIN(  25)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  25)												v4 = ((((((c7 >> 24) & 255) << 24) | ((c7 & 255) << 16)) | (((c7 >> 8) & 255) << 8)) | ((c7 >> 16) & 255));
            											}
            											else {
HXLINE(  25)												v4 = c7;
            											}
HXDLIN(  25)											int maskPixel1 = v4;
HXDLIN(  25)											int this55 = col1;
HXDLIN(  25)											if ((maskPixel1 == 0)) {
HXLINE(  25)												col1 = this55;
            											}
            											else {
HXLINE(  25)												Float m01;
HXDLIN(  25)												int this56 = ((maskPixel1 >> 24) & 255);
HXDLIN(  25)												if ((this56 == 0)) {
HXLINE(  25)													m01 = ((Float)0.);
            												}
            												else {
HXLINE(  25)													m01 = (( (Float)(this56) ) / ( (Float)(255) ));
            												}
HXDLIN(  25)												Float m11;
HXDLIN(  25)												int this57 = ((maskPixel1 >> 16) & 255);
HXDLIN(  25)												if ((this57 == 0)) {
HXLINE(  25)													m11 = ((Float)0.);
            												}
            												else {
HXLINE(  25)													m11 = (( (Float)(this57) ) / ( (Float)(255) ));
            												}
HXDLIN(  25)												Float m21;
HXDLIN(  25)												int this58 = ((maskPixel1 >> 8) & 255);
HXDLIN(  25)												if ((this58 == 0)) {
HXLINE(  25)													m21 = ((Float)0.);
            												}
            												else {
HXLINE(  25)													m21 = (( (Float)(this58) ) / ( (Float)(255) ));
            												}
HXDLIN(  25)												Float m31;
HXDLIN(  25)												int this59 = (maskPixel1 & 255);
HXDLIN(  25)												if ((this59 == 0)) {
HXLINE(  25)													m31 = ((Float)0.);
            												}
            												else {
HXLINE(  25)													m31 = (( (Float)(this59) ) / ( (Float)(255) ));
            												}
HXDLIN(  25)												int ch01 = ::Std_obj::_hx_int(((((Float)1.) - m01) * ( (Float)(((this55 >> 24) & 255)) )));
HXDLIN(  25)												int ch11 = ::Std_obj::_hx_int(((((Float)1.) - m11) * ( (Float)(((this55 >> 16) & 255)) )));
HXDLIN(  25)												int ch21 = ::Std_obj::_hx_int(((((Float)1.) - m21) * ( (Float)(((this55 >> 8) & 255)) )));
HXDLIN(  25)												int ch31 = ::Std_obj::_hx_int(((((Float)1.) - m31) * ( (Float)((this55 & 255)) )));
HXDLIN(  25)												col1 = ((((::Math_obj::round((( (Float)(ch01) ) * ( (Float)(255) ))) << 24) | (::Math_obj::round((( (Float)(ch11) ) * ( (Float)(255) ))) << 16)) | (::Math_obj::round((( (Float)(ch21) ) * ( (Float)(255) ))) << 8)) | ::Math_obj::round((( (Float)(ch31) ) * ( (Float)(255) ))));
            											}
            										}
HXDLIN(  25)										if ((col1 != 0)) {
HXLINE(  25)											int x6 = (dx1 - rectLeft1);
HXDLIN(  25)											int y6 = (dy1 - rectTop1);
HXDLIN(  25)											int c8 = col1;
HXDLIN(  25)											bool _hx_tmp15;
HXDLIN(  25)											if ((((c8 >> 24) & 255) < 254)) {
HXLINE(  25)												_hx_tmp15 = undoImage4->transparent;
            											}
            											else {
HXLINE(  25)												_hx_tmp15 = false;
            											}
HXDLIN(  25)											if (_hx_tmp15) {
HXLINE(  25)												int location3;
HXDLIN(  25)												if (undoImage4->useVirtualPos) {
HXLINE(  25)													location3 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage4->virtualY) * ( (Float)(undoImage4->width) )) + x6) - undoImage4->virtualX));
            												}
            												else {
HXLINE(  25)													location3 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage4->width) + x6)) ));
            												}
HXDLIN(  25)												int this60 = ::iterMagic::Iimg_obj::get(undoImage4->image,location3);
HXDLIN(  25)												int this61;
HXDLIN(  25)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  25)													this61 = ((((((this60 >> 24) & 255) << 24) | ((this60 & 255) << 16)) | (((this60 >> 8) & 255) << 8)) | ((this60 >> 16) & 255));
            												}
            												else {
HXLINE(  25)													this61 = this60;
            												}
HXDLIN(  25)												Float a14;
HXDLIN(  25)												int this62 = ((this61 >> 24) & 255);
HXDLIN(  25)												if ((this62 == 0)) {
HXLINE(  25)													a14 = ((Float)0.);
            												}
            												else {
HXLINE(  25)													a14 = (( (Float)(this62) ) / ( (Float)(255) ));
            												}
HXDLIN(  25)												Float r13;
HXDLIN(  25)												int this63 = ((this61 >> 16) & 255);
HXDLIN(  25)												if ((this63 == 0)) {
HXLINE(  25)													r13 = ((Float)0.);
            												}
            												else {
HXLINE(  25)													r13 = (( (Float)(this63) ) / ( (Float)(255) ));
            												}
HXDLIN(  25)												Float g13;
HXDLIN(  25)												int this64 = ((this61 >> 8) & 255);
HXDLIN(  25)												if ((this64 == 0)) {
HXLINE(  25)													g13 = ((Float)0.);
            												}
            												else {
HXLINE(  25)													g13 = (( (Float)(this64) ) / ( (Float)(255) ));
            												}
HXDLIN(  25)												Float b110;
HXDLIN(  25)												int this65 = (this61 & 255);
HXDLIN(  25)												if ((this65 == 0)) {
HXLINE(  25)													b110 = ((Float)0.);
            												}
            												else {
HXLINE(  25)													b110 = (( (Float)(this65) ) / ( (Float)(255) ));
            												}
HXDLIN(  25)												Float a23;
HXDLIN(  25)												int this66 = ((col1 >> 24) & 255);
HXDLIN(  25)												if ((this66 == 0)) {
HXLINE(  25)													a23 = ((Float)0.);
            												}
            												else {
HXLINE(  25)													a23 = (( (Float)(this66) ) / ( (Float)(255) ));
            												}
HXDLIN(  25)												Float r23;
HXDLIN(  25)												int this67 = ((col1 >> 16) & 255);
HXDLIN(  25)												if ((this67 == 0)) {
HXLINE(  25)													r23 = ((Float)0.);
            												}
            												else {
HXLINE(  25)													r23 = (( (Float)(this67) ) / ( (Float)(255) ));
            												}
HXDLIN(  25)												Float g23;
HXDLIN(  25)												int this68 = ((col1 >> 8) & 255);
HXDLIN(  25)												if ((this68 == 0)) {
HXLINE(  25)													g23 = ((Float)0.);
            												}
            												else {
HXLINE(  25)													g23 = (( (Float)(this68) ) / ( (Float)(255) ));
            												}
HXDLIN(  25)												Float b24;
HXDLIN(  25)												int this69 = (col1 & 255);
HXDLIN(  25)												if ((this69 == 0)) {
HXLINE(  25)													b24 = ((Float)0.);
            												}
            												else {
HXLINE(  25)													b24 = (( (Float)(this69) ) / ( (Float)(255) ));
            												}
HXDLIN(  25)												Float a33 = (a14 * (( (Float)(1) ) - a23));
HXDLIN(  25)												int r6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r13 * a33) + (r23 * a23))));
HXDLIN(  25)												int g6 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g13 * a33) + (g23 * a23))));
HXDLIN(  25)												int b25 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b110 * a33) + (b24 * a23))));
HXDLIN(  25)												int a15 = ::Std_obj::_hx_int((( (Float)(255) ) * (a33 + a23)));
HXDLIN(  25)												int blended3 = ((((a15 << 24) | (r6 << 16)) | (g6 << 8)) | b25);
HXDLIN(  25)												{
HXLINE(  25)													int _hx_tmp16;
HXDLIN(  25)													if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  25)														_hx_tmp16 = ((((((blended3 >> 24) & 255) << 24) | ((blended3 & 255) << 16)) | (((blended3 >> 8) & 255) << 8)) | ((blended3 >> 16) & 255));
            													}
            													else {
HXLINE(  25)														_hx_tmp16 = blended3;
            													}
HXDLIN(  25)													::iterMagic::Iimg_obj::set(undoImage4->image,location3,_hx_tmp16);
            												}
            											}
            											else {
HXLINE(  25)												::Dynamic this70 = undoImage4->image;
HXDLIN(  25)												int index7;
HXDLIN(  25)												if (undoImage4->useVirtualPos) {
HXLINE(  25)													index7 = ::Std_obj::_hx_int(((((( (Float)(y6) ) - undoImage4->virtualY) * ( (Float)(undoImage4->width) )) + x6) - undoImage4->virtualX));
            												}
            												else {
HXLINE(  25)													index7 = ::Std_obj::_hx_int(( (Float)(((y6 * undoImage4->width) + x6)) ));
            												}
HXDLIN(  25)												int _hx_tmp17;
HXDLIN(  25)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  25)													_hx_tmp17 = ((((((c8 >> 24) & 255) << 24) | ((c8 & 255) << 16)) | (((c8 >> 8) & 255) << 8)) | ((c8 >> 16) & 255));
            												}
            												else {
HXLINE(  25)													_hx_tmp17 = c8;
            												}
HXDLIN(  25)												::iterMagic::Iimg_obj::set(this70,index7,_hx_tmp17);
            											}
            										}
            										else {
HXLINE(  25)											if (forceClear1) {
HXLINE(  25)												::Dynamic this71 = undoImage4->image;
HXDLIN(  25)												int x7 = (dx1 - rectLeft1);
HXDLIN(  25)												int y7 = (dy1 - rectTop1);
HXDLIN(  25)												int index8;
HXDLIN(  25)												if (undoImage4->useVirtualPos) {
HXLINE(  25)													index8 = ::Std_obj::_hx_int(((((( (Float)(y7) ) - undoImage4->virtualY) * ( (Float)(undoImage4->width) )) + x7) - undoImage4->virtualX));
            												}
            												else {
HXLINE(  25)													index8 = ::Std_obj::_hx_int(( (Float)(((y7 * undoImage4->width) + x7)) ));
            												}
HXDLIN(  25)												::iterMagic::Iimg_obj::set(this71,index8,0);
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  25)				{
HXLINE(  25)					int _g_min2 = xIter31->start;
HXDLIN(  25)					int _g_max2 = xIter31->max;
HXDLIN(  25)					while((_g_min2 < _g_max2)){
HXLINE(  25)						_g_min2 = (_g_min2 + 1);
HXDLIN(  25)						int px1 = (_g_min2 - 1);
HXDLIN(  25)						Float pcx1 = (( (Float)(px1) ) - ( (Float)(28) ));
HXDLIN(  25)						{
HXLINE(  25)							int _g_min3 = yIter31->start;
HXDLIN(  25)							int _g_max3 = yIter31->max;
HXDLIN(  25)							while((_g_min3 < _g_max3)){
HXLINE(  25)								_g_min3 = (_g_min3 + 1);
HXDLIN(  25)								int py1 = (_g_min3 - 1);
HXDLIN(  25)								Float pcy1 = (( (Float)(py1) ) - ( (Float)(64) ));
HXDLIN(  25)								Float dot311 = ((pcx1 * bcx1) + (pcy1 * bcy1));
HXDLIN(  25)								Float dot321 = ((pcx1 * acx1) + (pcy1 * acy1));
HXDLIN(  25)								Float ratioA1 = (((dot221 * dot311) - (dot121 * dot321)) * denom11);
HXDLIN(  25)								Float ratioB1 = (((dot111 * dot321) - (dot121 * dot311)) * denom11);
HXDLIN(  25)								Float ratioC1 = ((((Float)1.0) - ratioB1) - ratioA1);
HXDLIN(  25)								bool _hx_tmp18;
HXDLIN(  25)								bool _hx_tmp19;
HXDLIN(  25)								if ((ratioA1 >= 0)) {
HXLINE(  25)									_hx_tmp19 = (ratioB1 >= 0);
            								}
            								else {
HXLINE(  25)									_hx_tmp19 = false;
            								}
HXDLIN(  25)								if (_hx_tmp19) {
HXLINE(  25)									_hx_tmp18 = (ratioC1 >= 0);
            								}
            								else {
HXLINE(  25)									_hx_tmp18 = false;
            								}
HXDLIN(  25)								if (_hx_tmp18) {
HXLINE(  25)									int i25 = ::Std_obj::_hx_int((((( (Float)(aA1) ) * ratioA1) + (( (Float)(aB1) ) * ratioB1)) + (( (Float)(aC1) ) * ratioC1)));
HXDLIN(  25)									if ((i25 > 255)) {
HXLINE(  24)										i25 = 255;
            									}
HXLINE(  25)									if ((i25 < 0)) {
HXLINE(  25)										i25 = 0;
            									}
HXDLIN(  25)									int a16 = i25;
HXDLIN(  25)									int i26 = ::Std_obj::_hx_int((((( (Float)(rA1) ) * ratioA1) + (( (Float)(rB1) ) * ratioB1)) + (( (Float)(rC1) ) * ratioC1)));
HXDLIN(  25)									if ((i26 > 255)) {
HXLINE(  24)										i26 = 255;
            									}
HXLINE(  25)									if ((i26 < 0)) {
HXLINE(  25)										i26 = 0;
            									}
HXDLIN(  25)									int r7 = i26;
HXDLIN(  25)									int i27 = ::Std_obj::_hx_int((((( (Float)(gA1) ) * ratioA1) + (( (Float)(gB1) ) * ratioB1)) + (( (Float)(gC1) ) * ratioC1)));
HXDLIN(  25)									if ((i27 > 255)) {
HXLINE(  24)										i27 = 255;
            									}
HXLINE(  25)									if ((i27 < 0)) {
HXLINE(  25)										i27 = 0;
            									}
HXDLIN(  25)									int g7 = i27;
HXDLIN(  25)									int i28 = ::Std_obj::_hx_int((((( (Float)(bA1) ) * ratioA1) + (( (Float)(bB1) ) * ratioB1)) + (( (Float)(bC1) ) * ratioC1)));
HXDLIN(  25)									if ((i28 > 255)) {
HXLINE(  24)										i28 = 255;
            									}
HXLINE(  25)									if ((i28 < 0)) {
HXLINE(  25)										i28 = 0;
            									}
HXDLIN(  25)									int b26 = i28;
HXDLIN(  25)									{
HXLINE(  25)										int location4;
HXDLIN(  25)										if (this48->useVirtualPos) {
HXLINE(  25)											location4 = ::Std_obj::_hx_int(((((( (Float)(py1) ) - this48->virtualY) * ( (Float)(this48->width) )) + px1) - this48->virtualX));
            										}
            										else {
HXLINE(  25)											location4 = ::Std_obj::_hx_int(( (Float)(((py1 * this48->width) + px1)) ));
            										}
HXDLIN(  25)										bool _hx_tmp20;
HXDLIN(  25)										if (this48->transparent) {
HXLINE(  25)											_hx_tmp20 = (a16 < 254);
            										}
            										else {
HXLINE(  25)											_hx_tmp20 = false;
            										}
HXDLIN(  25)										if (_hx_tmp20) {
HXLINE(  25)											int this72 = ::iterMagic::Iimg_obj::get(this48->image,location4);
HXDLIN(  25)											int old1;
HXDLIN(  25)											if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  25)												old1 = ((((((this72 >> 24) & 255) << 24) | ((this72 & 255) << 16)) | (((this72 >> 8) & 255) << 8)) | ((this72 >> 16) & 255));
            											}
            											else {
HXLINE(  25)												old1 = this72;
            											}
HXDLIN(  25)											int rhs1 = ((((a16 << 24) | (r7 << 16)) | (g7 << 8)) | b26);
HXDLIN(  25)											Float a17;
HXDLIN(  25)											int this73 = ((old1 >> 24) & 255);
HXDLIN(  25)											if ((this73 == 0)) {
HXLINE(  25)												a17 = ((Float)0.);
            											}
            											else {
HXLINE(  25)												a17 = (( (Float)(this73) ) / ( (Float)(255) ));
            											}
HXDLIN(  25)											Float r14;
HXDLIN(  25)											int this74 = ((old1 >> 16) & 255);
HXDLIN(  25)											if ((this74 == 0)) {
HXLINE(  25)												r14 = ((Float)0.);
            											}
            											else {
HXLINE(  25)												r14 = (( (Float)(this74) ) / ( (Float)(255) ));
            											}
HXDLIN(  25)											Float g14;
HXDLIN(  25)											int this75 = ((old1 >> 8) & 255);
HXDLIN(  25)											if ((this75 == 0)) {
HXLINE(  25)												g14 = ((Float)0.);
            											}
            											else {
HXLINE(  25)												g14 = (( (Float)(this75) ) / ( (Float)(255) ));
            											}
HXDLIN(  25)											Float b111;
HXDLIN(  25)											int this76 = (old1 & 255);
HXDLIN(  25)											if ((this76 == 0)) {
HXLINE(  25)												b111 = ((Float)0.);
            											}
            											else {
HXLINE(  25)												b111 = (( (Float)(this76) ) / ( (Float)(255) ));
            											}
HXDLIN(  25)											Float a24;
HXDLIN(  25)											int this77 = ((rhs1 >> 24) & 255);
HXDLIN(  25)											if ((this77 == 0)) {
HXLINE(  25)												a24 = ((Float)0.);
            											}
            											else {
HXLINE(  25)												a24 = (( (Float)(this77) ) / ( (Float)(255) ));
            											}
HXDLIN(  25)											Float r24;
HXDLIN(  25)											int this78 = ((rhs1 >> 16) & 255);
HXDLIN(  25)											if ((this78 == 0)) {
HXLINE(  25)												r24 = ((Float)0.);
            											}
            											else {
HXLINE(  25)												r24 = (( (Float)(this78) ) / ( (Float)(255) ));
            											}
HXDLIN(  25)											Float g24;
HXDLIN(  25)											int this79 = ((rhs1 >> 8) & 255);
HXDLIN(  25)											if ((this79 == 0)) {
HXLINE(  25)												g24 = ((Float)0.);
            											}
            											else {
HXLINE(  25)												g24 = (( (Float)(this79) ) / ( (Float)(255) ));
            											}
HXDLIN(  25)											Float b27;
HXDLIN(  25)											int this80 = (rhs1 & 255);
HXDLIN(  25)											if ((this80 == 0)) {
HXLINE(  25)												b27 = ((Float)0.);
            											}
            											else {
HXLINE(  25)												b27 = (( (Float)(this80) ) / ( (Float)(255) ));
            											}
HXDLIN(  25)											Float a34 = (a17 * (( (Float)(1) ) - a24));
HXDLIN(  25)											int r8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((r14 * a34) + (r24 * a24))));
HXDLIN(  25)											int g8 = ::Std_obj::_hx_int((( (Float)(255) ) * ((g14 * a34) + (g24 * a24))));
HXDLIN(  25)											int b28 = ::Std_obj::_hx_int((( (Float)(255) ) * ((b111 * a34) + (b27 * a24))));
HXDLIN(  25)											int a18 = ::Std_obj::_hx_int((( (Float)(255) ) * (a34 + a24)));
HXDLIN(  25)											int blended4 = ((((a18 << 24) | (r8 << 16)) | (g8 << 8)) | b28);
HXDLIN(  25)											{
HXLINE(  25)												int _hx_tmp21;
HXDLIN(  25)												if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  25)													_hx_tmp21 = ((((((blended4 >> 24) & 255) << 24) | ((blended4 & 255) << 16)) | (((blended4 >> 8) & 255) << 8)) | ((blended4 >> 16) & 255));
            												}
            												else {
HXLINE(  25)													_hx_tmp21 = blended4;
            												}
HXDLIN(  25)												::iterMagic::Iimg_obj::set(this48->image,location4,_hx_tmp21);
            											}
            										}
            										else {
HXLINE(  25)											int value1;
HXDLIN(  25)											if (this48->isLittle) {
HXLINE(  25)												value1 = ((((a16 << 24) | (b26 << 16)) | (g7 << 8)) | r7);
            											}
            											else {
HXLINE(  25)												value1 = ((((a16 << 24) | (r7 << 16)) | (g7 << 8)) | b26);
            											}
HXDLIN(  25)											::iterMagic::Iimg_obj::set(this48->image,location4,value1);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXDLIN(  25)				if ((hasHit1 == false)) {
HXLINE(  25)					 ::pi_xy::iter::IntIterStart v_yIter31;
HXDLIN(  25)					 ::pi_xy::iter::IntIterStart v_xIter31;
HXDLIN(  25)					int v_undoY1;
HXDLIN(  25)					int v_undoX1;
HXDLIN(  25)					Float v_ty1;
HXDLIN(  25)					Float v_tx1;
HXDLIN(  25)					Float v_t01;
HXDLIN(  25)					Float v_sy1;
HXDLIN(  25)					Float v_sx1;
HXDLIN(  25)					Float v_s01;
HXDLIN(  25)					Float v_A1;
HXDLIN(  25)					 ::pi_xy::ImageStruct v_undoImage1 = null();
HXDLIN(  25)					Float bx1 = ( (Float)(70) );
HXDLIN(  25)					Float by1 = ( (Float)(60) );
HXDLIN(  25)					Float cx1 = ( (Float)(28) );
HXDLIN(  25)					Float cy1 = ( (Float)(64) );
HXDLIN(  25)					bool adjustWinding1 = (((((( (Float)(22) ) * by1) - (bx1 * ( (Float)(23) ))) + ((bx1 * cy1) - (cx1 * by1))) + ((cx1 * ( (Float)(23) )) - (( (Float)(22) ) * cy1))) > 0);
HXDLIN(  25)					if (!(adjustWinding1)) {
HXLINE(  25)						Float bx_1 = bx1;
HXDLIN(  25)						Float by_1 = by1;
HXLINE(  24)						bx1 = cx1;
HXLINE(  25)						by1 = cy1;
HXLINE(  26)						cx1 = bx_1;
HXLINE(  27)						cy1 = by_1;
            					}
HXLINE(  25)					Float v_ax1 = ( (Float)(22) );
HXDLIN(  25)					Float v_ay1 = ( (Float)(23) );
HXDLIN(  25)					Float v_bx1 = bx1;
HXDLIN(  25)					Float v_by1 = by1;
HXDLIN(  25)					Float v_cx1 = cx1;
HXDLIN(  25)					Float v_cy1 = cy1;
HXDLIN(  25)					bool v_preCalculated1 = true;
HXDLIN(  25)					{
HXLINE(  25)						v_s01 = ((v_ay1 * v_cx1) - (v_ax1 * v_cy1));
HXDLIN(  25)						v_sx1 = (v_cy1 - v_ay1);
HXDLIN(  25)						v_sy1 = (v_ax1 - v_cx1);
HXDLIN(  25)						v_t01 = ((v_ax1 * v_by1) - (v_ay1 * v_bx1));
HXDLIN(  25)						v_tx1 = (v_ay1 - v_by1);
HXDLIN(  25)						v_ty1 = (v_bx1 - v_ax1);
HXDLIN(  25)						v_A1 = ((((-(v_by1) * v_cx1) + (v_ay1 * (-(v_bx1) + v_cx1))) + (v_ax1 * (v_by1 - v_cy1))) + (v_bx1 * v_cy1));
HXDLIN(  25)						Float a19 = v_ax1;
HXDLIN(  25)						Float b29 = v_bx1;
HXDLIN(  25)						Float c9 = v_cx1;
HXDLIN(  25)						if ((a19 > b29)) {
HXLINE(  25)							if ((a19 > c9)) {
HXLINE(  25)								int min4;
HXDLIN(  25)								if ((b29 > c9)) {
HXLINE(  25)									min4 = ::Math_obj::floor(c9);
            								}
            								else {
HXLINE(  25)									min4 = ::Math_obj::floor(b29);
            								}
HXDLIN(  25)								int ii_min12 = min4;
HXDLIN(  25)								int ii_max12 = ::Math_obj::ceil(a19);
HXDLIN(  25)								v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min12,ii_max12);
            							}
            							else {
HXLINE(  25)								int ii_min13 = ::Math_obj::floor(b29);
HXDLIN(  25)								int ii_max13 = ::Math_obj::ceil(c9);
HXDLIN(  25)								v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min13,ii_max13);
            							}
            						}
            						else {
HXLINE(  25)							if ((b29 > c9)) {
HXLINE(  25)								int min5;
HXDLIN(  25)								if ((a19 > c9)) {
HXLINE(  25)									min5 = ::Math_obj::floor(c9);
            								}
            								else {
HXLINE(  25)									min5 = ::Math_obj::ceil(a19);
            								}
HXDLIN(  25)								int ii_min14 = min5;
HXDLIN(  25)								int ii_max14 = ::Math_obj::ceil(b29);
HXDLIN(  25)								v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min14,ii_max14);
            							}
            							else {
HXLINE(  25)								int ii_min15 = ::Math_obj::floor(a19);
HXDLIN(  25)								int ii_max15 = ::Math_obj::ceil(c9);
HXDLIN(  25)								v_xIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min15,ii_max15);
            							}
            						}
HXDLIN(  25)						Float a20 = v_ay1;
HXDLIN(  25)						Float b30 = v_by1;
HXDLIN(  25)						Float c10 = v_cy1;
HXDLIN(  25)						if ((a20 > b30)) {
HXLINE(  25)							if ((a20 > c10)) {
HXLINE(  25)								int min6;
HXDLIN(  25)								if ((b30 > c10)) {
HXLINE(  25)									min6 = ::Math_obj::floor(c10);
            								}
            								else {
HXLINE(  25)									min6 = ::Math_obj::floor(b30);
            								}
HXDLIN(  25)								int ii_min16 = min6;
HXDLIN(  25)								int ii_max16 = ::Math_obj::ceil(a20);
HXDLIN(  25)								v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min16,ii_max16);
            							}
            							else {
HXLINE(  25)								int ii_min17 = ::Math_obj::floor(b30);
HXDLIN(  25)								int ii_max17 = ::Math_obj::ceil(c10);
HXDLIN(  25)								v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min17,ii_max17);
            							}
            						}
            						else {
HXLINE(  25)							if ((b30 > c10)) {
HXLINE(  25)								int min7;
HXDLIN(  25)								if ((a20 > c10)) {
HXLINE(  25)									min7 = ::Math_obj::floor(c10);
            								}
            								else {
HXLINE(  25)									min7 = ::Math_obj::ceil(a20);
            								}
HXDLIN(  25)								int ii_min18 = min7;
HXDLIN(  25)								int ii_max18 = ::Math_obj::ceil(b30);
HXDLIN(  25)								v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min18,ii_max18);
            							}
            							else {
HXLINE(  25)								int ii_min19 = ::Math_obj::floor(a20);
HXDLIN(  25)								int ii_max19 = ::Math_obj::ceil(c10);
HXDLIN(  25)								v_yIter31 =  ::pi_xy::iter::IntIterStart_obj::__alloc( HX_CTX ,ii_min19,ii_max19);
            							}
            						}
            					}
HXDLIN(  25)					if (hasUndo1) {
HXLINE(  25)						v_undoImage1 = undoImage4;
HXDLIN(  25)						v_undoX1 = xIter31->start;
HXDLIN(  25)						v_undoY1 = yIter31->start;
            					}
            				}
            			}
            		}
HXLINE(  26)		{
HXLINE(  26)			 ::pi_xy::ImageStruct this81 = p;
HXDLIN(  26)			{
HXLINE(  26)				 ::pi_xy::imageAbstracts::RGBratios ratios = null();
HXDLIN(  26)				{
HXLINE(  26)					{
HXLINE(  26)						::String s;
HXDLIN(  26)						bool s1;
HXDLIN(  26)						if (!(::ANSI_obj::strip)) {
HXLINE(  26)							if (::ANSI_obj::stripIfUnavailable) {
HXLINE(  26)								s1 = !(::ANSI_obj::available);
            							}
            							else {
HXLINE(  26)								s1 = false;
            							}
            						}
            						else {
HXLINE(  26)							s1 = true;
            						}
HXDLIN(  26)						if (s1) {
HXLINE(  26)							s = HX_("",00,00,00,00);
            						}
            						else {
HXLINE(  26)							s = (((HX_("\x1b""",1b,00,00,00) + HX_("]0;",a8,bb,46,00)) + HX_("Output",21,83,15,41)) + HX_("\x07""",07,00,00,00));
            						}
HXDLIN(  26)						if (::hx::IsNull( s )) {
HXLINE(  68)							s = HX_("",00,00,00,00);
            						}
HXLINE(  26)						::Sys_obj::_hx_stdout()->writeString((s + HX_("\n",0a,00,00,00)),null());
            					}
HXDLIN(  26)					{
HXLINE(  26)						::String s2;
HXDLIN(  26)						bool s3;
HXDLIN(  26)						if (!(::ANSI_obj::strip)) {
HXLINE(  26)							if (::ANSI_obj::stripIfUnavailable) {
HXLINE(  26)								s3 = !(::ANSI_obj::available);
            							}
            							else {
HXLINE(  26)								s3 = false;
            							}
            						}
            						else {
HXLINE(  26)							s3 = true;
            						}
HXDLIN(  26)						if (s3) {
HXLINE(  26)							s2 = HX_("",00,00,00,00);
            						}
            						else {
HXLINE(  26)							s2 = HX_("\x1b""[2J",b8,fb,1d,12);
            						}
HXDLIN(  26)						if (::hx::IsNull( s2 )) {
HXLINE(  69)							s2 = HX_("",00,00,00,00);
            						}
HXLINE(  26)						::Sys_obj::_hx_stdout()->writeString((s2 + HX_("\n",0a,00,00,00)),null());
            					}
HXDLIN(  26)					{
HXLINE(  26)						::String s4 = ( (::String)(::ANSI_obj::set(::Attribute_obj::BlackBack_dyn())) );
HXDLIN(  26)						if (::hx::IsNull( s4 )) {
HXLINE(  70)							s4 = HX_("",00,00,00,00);
            						}
HXLINE(  26)						::Sys_obj::_hx_stdout()->writeString((s4 + HX_("\n",0a,00,00,00)),null());
            					}
            				}
HXDLIN(  26)				if (::hx::IsNull( ratios )) {
HXLINE(  53)					ratios =  ::pi_xy::imageAbstracts::RGBratios_obj::__alloc( HX_CTX ,((Float)0.21),((Float)0.72),((Float)0.07));
            				}
HXLINE(  26)				{
HXLINE(  26)					int p1;
HXDLIN(  26)					Float pf_r;
HXDLIN(  26)					Float pf_g;
HXDLIN(  26)					Float pf_b;
HXDLIN(  26)					Float pf_a;
HXDLIN(  26)					int w3 = this81->width;
HXDLIN(  26)					int h = this81->height;
HXDLIN(  26)					::String brightness = (((HX_(" .'`^",97,4c,58,8b) + HX_("\",:;Il!i><~+_-?][}{1)(|",78,0d,a9,80)) + HX_("\\",5c,00,00,00)) + HX_W(u"/tfjrxnuvczXYUJCLQ0OZmwqpdbkhao*#MW&8%B@$\u2588",ce8c,337f));
HXDLIN(  26)					Float l3;
HXDLIN(  26)					bool toggle = true;
HXDLIN(  26)					int scale1 = brightness.length;
HXDLIN(  26)					::ANSI_obj::set(::Attribute_obj::White_dyn());
HXDLIN(  26)					::String str = HX_("",00,00,00,00);
HXLINE( 100)					w3 = ::Std_obj::_hx_int(::Math_obj::min((( (Float)(w3) ) * ((Float)1.)),( (Float)(99) )));
HXLINE( 101)					h = ::Std_obj::_hx_int(::Math_obj::min((( (Float)(h) ) * ((Float)1.)),( (Float)(84) )));
HXLINE(  26)					bool r9;
HXDLIN(  26)					bool b31;
HXDLIN(  26)					bool g9;
HXDLIN(  26)					Float c11;
HXDLIN(  26)					Float ratiosR = (((Float)0.3) - (ratios->r / ( (Float)(2) )));
HXDLIN(  26)					Float ratiosG = (((Float)0.3) - (ratios->g / ( (Float)(2) )));
HXDLIN(  26)					Float ratiosB = (((Float)0.3) - (ratios->b / ( (Float)(2) )));
HXDLIN(  26)					 ::Attribute color = ::Attribute_obj::White_dyn();
HXDLIN(  26)					{
HXLINE(  26)						int _g64 = 0;
HXDLIN(  26)						int _g65 = w3;
HXDLIN(  26)						while((_g64 < _g65)){
HXLINE(  26)							_g64 = (_g64 + 1);
HXDLIN(  26)							int x8 = (_g64 - 1);
HXDLIN(  26)							if (toggle) {
HXLINE(  26)								int _g66 = 0;
HXDLIN(  26)								int _g67 = h;
HXDLIN(  26)								while((_g66 < _g67)){
HXLINE(  26)									_g66 = (_g66 + 1);
HXDLIN(  26)									int y8 = (_g66 - 1);
HXDLIN(  26)									int x9 = ::Math_obj::round((( (Float)(x8) ) / ((Float)1.)));
HXDLIN(  26)									int y9 = ::Math_obj::round((( (Float)(y8) ) / ((Float)1.)));
HXDLIN(  26)									::Dynamic this82 = this81->image;
HXDLIN(  26)									int index9;
HXDLIN(  26)									if (this81->useVirtualPos) {
HXLINE(  26)										index9 = ::Std_obj::_hx_int(((((( (Float)(y9) ) - this81->virtualY) * ( (Float)(this81->width) )) + x9) - this81->virtualX));
            									}
            									else {
HXLINE(  26)										index9 = ::Std_obj::_hx_int(( (Float)(((y9 * this81->width) + x9)) ));
            									}
HXDLIN(  26)									int c12 = ::iterMagic::Iimg_obj::get(this82,index9);
HXDLIN(  26)									if (::pi_xy::_Endian::Endian_Fields__obj::isLittleEndian) {
HXLINE(  26)										p1 = ((((((c12 >> 24) & 255) << 24) | ((c12 & 255) << 16)) | (((c12 >> 8) & 255) << 8)) | ((c12 >> 16) & 255));
            									}
            									else {
HXLINE(  26)										p1 = c12;
            									}
HXDLIN(  26)									Float a25 = (( (Float)(((p1 >> 24) & 255)) ) / ( (Float)(255) ));
HXDLIN(  26)									Float r10 = (( (Float)(((p1 >> 16) & 255)) ) / ( (Float)(255) ));
HXDLIN(  26)									Float g10 = (( (Float)(((p1 >> 8) & 255)) ) / ( (Float)(255) ));
HXDLIN(  26)									Float b32 = (( (Float)((p1 & 255)) ) / ( (Float)(255) ));
HXDLIN(  26)									pf_a = a25;
HXDLIN(  26)									pf_r = r10;
HXDLIN(  26)									pf_g = g10;
HXDLIN(  26)									pf_b = b32;
HXLINE( 115)									l3 = ((pf_a * (((((Float)0.21) * pf_r) + (((Float)0.72) * pf_g)) + (((Float)0.07) * pf_b))) * ( (Float)(scale1) ));
HXLINE( 116)									r9 = (pf_r > ratiosR);
HXLINE( 117)									g9 = (pf_g > ratiosG);
HXLINE( 118)									b31 = (pf_r > ratiosB);
HXLINE( 119)									color = ::Attribute_obj::White_dyn();
HXLINE(  26)									bool _hx_tmp22;
HXDLIN(  26)									bool _hx_tmp23;
HXDLIN(  26)									if (r9) {
HXLINE(  26)										_hx_tmp23 = b31;
            									}
            									else {
HXLINE(  26)										_hx_tmp23 = false;
            									}
HXDLIN(  26)									if (_hx_tmp23) {
HXLINE(  26)										_hx_tmp22 = g9;
            									}
            									else {
HXLINE(  26)										_hx_tmp22 = false;
            									}
HXDLIN(  26)									if (_hx_tmp22) {
HXLINE( 121)										color = ::Attribute_obj::White_dyn();
            									}
            									else {
HXLINE(  26)										bool _hx_tmp24;
HXDLIN(  26)										bool _hx_tmp25;
HXDLIN(  26)										if (!(r9)) {
HXLINE(  26)											_hx_tmp25 = !(g9);
            										}
            										else {
HXLINE(  26)											_hx_tmp25 = false;
            										}
HXDLIN(  26)										if (_hx_tmp25) {
HXLINE(  26)											_hx_tmp24 = !(b31);
            										}
            										else {
HXLINE(  26)											_hx_tmp24 = false;
            										}
HXDLIN(  26)										if (_hx_tmp24) {
HXLINE( 124)											color = ::Attribute_obj::Black_dyn();
            										}
            										else {
HXLINE(  26)											if (r9) {
HXLINE(  26)												if (g9) {
HXLINE( 128)													color = ::Attribute_obj::Yellow_dyn();
            												}
            												else {
HXLINE(  26)													if (b31) {
HXLINE( 130)														color = ::Attribute_obj::Magenta_dyn();
            													}
            													else {
HXLINE( 132)														color = ::Attribute_obj::Red_dyn();
            													}
            												}
            											}
            											else {
HXLINE(  26)												if (g9) {
HXLINE(  26)													if (b31) {
HXLINE( 136)														color = ::Attribute_obj::Cyan_dyn();
            													}
            													else {
HXLINE( 138)														color = ::Attribute_obj::Green_dyn();
            													}
            												}
            												else {
HXLINE( 141)													color = ::Attribute_obj::Blue_dyn();
            												}
            											}
            										}
            									}
HXLINE(  26)									int column = ::Std_obj::_hx_int(( (Float)((x8 + 1)) ));
HXDLIN(  26)									int line = ::Std_obj::_hx_int(((( (Float)(y8) ) / ( (Float)(2) )) + 1));
HXDLIN(  26)									::String str1;
HXDLIN(  26)									bool str2;
HXDLIN(  26)									if (!(::ANSI_obj::strip)) {
HXLINE(  26)										if (::ANSI_obj::stripIfUnavailable) {
HXLINE(  26)											str2 = !(::ANSI_obj::available);
            										}
            										else {
HXLINE(  26)											str2 = false;
            										}
            									}
            									else {
HXLINE(  26)										str2 = true;
            									}
HXDLIN(  26)									if (str2) {
HXLINE(  26)										str1 = HX_("",00,00,00,00);
            									}
            									else {
HXLINE(  26)										str1 = ((((HX_("\x1b""[",e0,17,00,00) + line) + HX_(";",3b,00,00,00)) + column) + HX_("H",48,00,00,00));
            									}
HXDLIN(  26)									::String str3 = (str1 + ::Std_obj::string(::ANSI_obj::set(color)));
HXDLIN(  26)									str = (str + (str3 + brightness.charAt(::Std_obj::_hx_int(( (Float)(::Math_obj::round(l3)) )))));
            								}
            							}
HXLINE( 148)							toggle = !(toggle);
            						}
            					}
HXLINE(  26)					int line1 = ::Std_obj::_hx_int(( (Float)((::Math_obj::round((( (Float)(h) ) / ( (Float)(2) ))) + 1)) ));
HXDLIN(  26)					::String str4;
HXDLIN(  26)					bool str5;
HXDLIN(  26)					if (!(::ANSI_obj::strip)) {
HXLINE(  26)						if (::ANSI_obj::stripIfUnavailable) {
HXLINE(  26)							str5 = !(::ANSI_obj::available);
            						}
            						else {
HXLINE(  26)							str5 = false;
            						}
            					}
            					else {
HXLINE(  26)						str5 = true;
            					}
HXDLIN(  26)					if (str5) {
HXLINE(  26)						str4 = HX_("",00,00,00,00);
            					}
            					else {
HXLINE(  26)						str4 = ((((HX_("\x1b""[",e0,17,00,00) + line1) + HX_(";",3b,00,00,00)) + 0) + HX_("H",48,00,00,00));
            					}
HXDLIN(  26)					str = (str + str4);
HXDLIN(  26)					str = (str + ::Std_obj::string(::ANSI_obj::set(::Attribute_obj::White_dyn())));
HXDLIN(  26)					{
HXLINE(  26)						::String s5 = str;
HXDLIN(  26)						if (::hx::IsNull( s5 )) {
HXLINE( 152)							s5 = HX_("",00,00,00,00);
            						}
HXLINE(  26)						::Sys_obj::_hx_stdout()->writeString((s5 + HX_("\n",0a,00,00,00)),null());
            					}
            				}
            			}
            		}
            	}

Dynamic Main_obj::__CreateEmpty() { return new Main_obj; }

void *Main_obj::_hx_vtable = 0;

Dynamic Main_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Main_obj > _hx_result = new Main_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Main_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x70592103;
}

void Main_obj::main(){
            	HX_GC_STACKFRAME(&_hx_pos_78f112240a2e3029_5_main)
HXDLIN(   5)		 ::pi_xyAnsi::Main_obj::__alloc( HX_CTX );
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Main_obj,main,(void))


::hx::ObjectPtr< Main_obj > Main_obj::__new() {
	::hx::ObjectPtr< Main_obj > __this = new Main_obj();
	__this->__construct();
	return __this;
}

::hx::ObjectPtr< Main_obj > Main_obj::__alloc(::hx::Ctx *_hx_ctx) {
	Main_obj *__this = (Main_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(Main_obj), false, "pi_xyAnsi.Main"));
	*(void **)__this = Main_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

Main_obj::Main_obj()
{
}

bool Main_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"main") ) { outValue = main_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *Main_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *Main_obj_sStaticStorageInfo = 0;
#endif

::hx::Class Main_obj::__mClass;

static ::String Main_obj_sStaticFields[] = {
	HX_("main",39,38,56,48),
	::String(null())
};

void Main_obj::__register()
{
	Main_obj _hx_dummy;
	Main_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("pi_xyAnsi.Main",1d,92,7a,f5);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Main_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Main_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< Main_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Main_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Main_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace pi_xyAnsi
